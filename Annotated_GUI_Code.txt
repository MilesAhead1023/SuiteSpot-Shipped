// ======================================================================================
// FILE: ConstantsUI.h
// ======================================================================================
#pragma once                                                                                // Ensures this header file is included only once during compilation to prevent duplicate definitions.
#include "IMGUI/imgui.h"                                                                    // Include the ImGui library header to access ImGui types like ImVec4, used for color definitions.

// Centralized UI constants for SuiteSpot plugin                                            // Comment: Explains the purpose of the file.
// Each constant is named specifically for the UI element it controls                       // Comment: Explains the naming convention.
// for maximum granularity and ease of individual component editing                         // Comment: Explains the design philosophy.

namespace UI {                                                                              // Begin the UI namespace to organize UI-related code and avoid name collisions.

	// ===================================================================                  // Comment: Visual separator.
	// GLOBAL UI CONSTANTS                                                                  // Comment: Section header for global constants.
	// ===================================================================                  // Comment: Visual separator.

	// Font scale applied to all SuiteSpot windows (per-window, not global)                 // Comment: Documentation for FONT_SCALE.
	constexpr float FONT_SCALE = 1.12f;                                                     // Defines the scaling factor for text rendering within the UI windows to improve readability.

	// ===================================================================                  // Comment: Visual separator.
	// SETTINGS UI CONSTANTS                                                                // Comment: Section header for Settings UI constants.
	// ===================================================================                  // Comment: Visual separator.
	namespace SettingsUI {                                                                  // Begin the SettingsUI sub-namespace.

		// === Dropdown Widths ===                                                          // Comment: Section for dropdown width constants.

		// Width of the "Freeplay Maps" dropdown in Map Selection tab                       // Comment: Documentation for FREEPLAY_MAPS_DROPDOWN_WIDTH.
		constexpr float FREEPLAY_MAPS_DROPDOWN_WIDTH = 260.0f;                              // Defines the width in pixels for the Freeplay map selector dropdown.

		// Width of the "Training Packs" dropdown in Map Selection tab                      // Comment: Documentation for TRAINING_PACKS_DROPDOWN_WIDTH.
		constexpr float TRAINING_PACKS_DROPDOWN_WIDTH = 260.0f;                             // Defines the width in pixels for the Training Pack selector dropdown.

		// Width of the "Workshop Maps" dropdown in Map Selection tab                       // Comment: Documentation for WORKSHOP_MAPS_DROPDOWN_WIDTH.
		constexpr float WORKSHOP_MAPS_DROPDOWN_WIDTH = 260.0f;                              // Defines the width in pixels for the Workshop Map selector dropdown.

		// === Input Box Widths ===                                                         // Comment: Section for input box width constants.

		// Width of the "Delay Freeplay (sec)" input box in Map Selection tab               // Comment: Documentation for DELAY_FREEPLAY_INPUT_WIDTH.
		constexpr float DELAY_FREEPLAY_INPUT_WIDTH = 220.0f;                                // Defines the width in pixels for the Freeplay delay input field.

		// Width of the "Delay Training (sec)" input box in Map Selection tab               // Comment: Documentation for DELAY_TRAINING_INPUT_WIDTH.
		constexpr float DELAY_TRAINING_INPUT_WIDTH = 220.0f;                                // Defines the width in pixels for the Training delay input field.

		// Width of the "Delay Workshop (sec)" input box in Map Selection tab               // Comment: Documentation for DELAY_WORKSHOP_INPUT_WIDTH.
		constexpr float DELAY_WORKSHOP_INPUT_WIDTH = 220.0f;                                // Defines the width in pixels for the Workshop delay input field.

		// Width of the "Delay Queue (sec)" input box in Auto-Queue tab                     // Comment: Documentation for DELAY_QUEUE_INPUT_WIDTH.
		constexpr float DELAY_QUEUE_INPUT_WIDTH = 220.0f;                                   // Defines the width in pixels for the Auto-Queue delay input field.

		// Width of the "Workshop maps root folder" input in Workshop Source section        // Comment: Documentation for WORKSHOP_PATH_INPUT_WIDTH.
		constexpr float WORKSHOP_PATH_INPUT_WIDTH = 420.0f;                                 // Defines the width in pixels for the Workshop path input field.

		// === Range Limits (Min/Max Values) ===                                            // Comment: Section for value range constants.

		// Minimum value for Freeplay delay slider (seconds)                                // Comment: Documentation for DELAY_FREEPLAY_MIN_SECONDS.
		constexpr int DELAY_FREEPLAY_MIN_SECONDS = 0;                                       // Defines the lower bound (0 seconds) for the Freeplay delay setting.

		// Maximum value for Freeplay delay slider (seconds)                                // Comment: Documentation for DELAY_FREEPLAY_MAX_SECONDS.
		constexpr int DELAY_FREEPLAY_MAX_SECONDS = 300;                                     // Defines the upper bound (300 seconds) for the Freeplay delay setting.

		// Minimum value for Training delay slider (seconds)                                // Comment: Documentation for DELAY_TRAINING_MIN_SECONDS.
		constexpr int DELAY_TRAINING_MIN_SECONDS = 0;                                       // Defines the lower bound (0 seconds) for the Training delay setting.

		// Maximum value for Training delay slider (seconds)                                // Comment: Documentation for DELAY_TRAINING_MAX_SECONDS.
		constexpr int DELAY_TRAINING_MAX_SECONDS = 300;                                     // Defines the upper bound (300 seconds) for the Training delay setting.

		// Minimum value for Workshop delay slider (seconds)                                // Comment: Documentation for DELAY_WORKSHOP_MIN_SECONDS.
		constexpr int DELAY_WORKSHOP_MIN_SECONDS = 0;                                       // Defines the lower bound (0 seconds) for the Workshop delay setting.

		// Maximum value for Workshop delay slider (seconds)                                // Comment: Documentation for DELAY_WORKSHOP_MAX_SECONDS.
		constexpr int DELAY_WORKSHOP_MAX_SECONDS = 300;                                     // Defines the upper bound (300 seconds) for the Workshop delay setting.

		// Minimum value for Queue delay slider (seconds)                                   // Comment: Documentation for DELAY_QUEUE_MIN_SECONDS.
		constexpr int DELAY_QUEUE_MIN_SECONDS = 0;                                          // Defines the lower bound (0 seconds) for the Auto-Queue delay setting.

		// Maximum value for Queue delay slider (seconds)                                   // Comment: Documentation for DELAY_QUEUE_MAX_SECONDS.
		constexpr int DELAY_QUEUE_MAX_SECONDS = 300;                                        // Defines the upper bound (300 seconds) for the Auto-Queue delay setting.

		// === Positions and Spacing ===                                                    // Comment: Section for layout positioning constants.

		// Horizontal position for status text display in General tab                       // Comment: Documentation for STATUS_TEXT_POSITION_X.
		constexpr float STATUS_TEXT_POSITION_X = 420.0f;                                    // Defines the absolute X-coordinate for status text alignment.

		// Spacing between radio buttons in Map Type selection                              // Comment: Documentation for MAP_TYPE_RADIO_BUTTON_SPACING.
		constexpr float MAP_TYPE_RADIO_BUTTON_SPACING = 16.0f;                              // Defines the padding in pixels between adjacent radio buttons.

		// === Status Colors ===                                                            // Comment: Section for color constants.

		// Text color for section headers in settings (brightened from 0.6)                 // Comment: Documentation for HEADER_TEXT_COLOR.
		inline const ImVec4 HEADER_TEXT_COLOR = ImVec4(0.9f, 0.9f, 0.9f, 1.0f);             // Defines an ImVec4 color (Light Gray) for section headers.

		// Color for separator line in status section (white)                               // Comment: Documentation for STATUS_SEPARATOR_COLOR.
		inline const ImVec4 STATUS_SEPARATOR_COLOR = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);        // Defines an ImVec4 color (White) for separator lines.

		// Text color for "Enabled" status in Auto-Load settings (bright green)             // Comment: Documentation for STATUS_ENABLED_TEXT_COLOR.
		inline const ImVec4 STATUS_ENABLED_TEXT_COLOR = ImVec4(0.2f, 1.0f, 0.2f, 1.0f);     // Defines an ImVec4 color (Green) for "Enabled" status text.

		// Text color for "Disabled" status in Auto-Load settings (bright red)              // Comment: Documentation for STATUS_DISABLED_TEXT_COLOR.
		inline const ImVec4 STATUS_DISABLED_TEXT_COLOR = ImVec4(1.0f, 0.3f, 0.3f, 1.0f);    // Defines an ImVec4 color (Red) for "Disabled" status text.

		// === Timer Durations ===                                                          // Comment: Section for timer constants.

		// Duration (seconds) for success message fadeout after adding custom training pack // Comment: Documentation for CUSTOM_PACK_SUCCESS_MESSAGE_DURATION.
		constexpr float CUSTOM_PACK_SUCCESS_MESSAGE_DURATION = 3.0f;                        // Defines the duration in seconds for the success message to remain visible.

		// Duration (seconds) for error message fadeout in workshop path validation         // Comment: Documentation for WORKSHOP_PATH_ERROR_MESSAGE_DURATION.
		constexpr float WORKSHOP_PATH_ERROR_MESSAGE_DURATION = 2.0f;                        // Defines the duration in seconds for the error message to remain visible.

		// Divisor used to calculate alpha fade effect for success messages (timer / divisor) // Comment: Documentation for SUCCESS_MESSAGE_FADE_DIVISOR.
		constexpr float SUCCESS_MESSAGE_FADE_DIVISOR = 3.0f;                                // Defines the divisor used to calculate the fade-out speed/curve.

		// === Message Colors ===                                                           // Comment: Section for message color constants.

		// Text color for success message "Pack added!" in custom training form (green)     // Comment: Documentation for CUSTOM_PACK_SUCCESS_TEXT_COLOR.
		inline const ImVec4 CUSTOM_PACK_SUCCESS_TEXT_COLOR = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);// Defines an ImVec4 color (Pure Green) for success messages.

	}  // namespace SettingsUI                                                              // End of SettingsUI sub-namespace.

	// ===================================================================                  // Comment: Visual separator.
	// TRAINING PACK UI CONSTANTS                                                           // Comment: Section header for Training Pack UI constants.
	// ===================================================================                  // Comment: Visual separator.
	namespace TrainingPackUI {                                                              // Begin the TrainingPackUI sub-namespace.

		// === Filter Layout - Responsive Widths ===                                        // Comment: Section for responsive layout constants.

		// Percentage of available width for Search filter box in Training Packs tab (40%)  // Comment: Documentation for FILTER_SEARCH_WIDTH_PERCENT.
		constexpr float FILTER_SEARCH_WIDTH_PERCENT = 0.40f;                                // Defines the proportional width (40%) for the search filter.

		// Percentage of available width for Difficulty filter dropdown in Training Packs tab (25%) // Comment: Documentation for FILTER_DIFFICULTY_WIDTH_PERCENT.
		constexpr float FILTER_DIFFICULTY_WIDTH_PERCENT = 0.25f;                            // Defines the proportional width (25%) for the difficulty dropdown.

		// Percentage of available width for Shots filter in Training Packs tab (35%)       // Comment: Documentation for FILTER_SHOTS_WIDTH_PERCENT.
		constexpr float FILTER_SHOTS_WIDTH_PERCENT = 0.35f;                                 // Defines the proportional width (35%) for the shots filter.

		// Minimum pixel width for Search filter box (used when window is too narrow)       // Comment: Documentation for FILTER_SEARCH_MIN_WIDTH.
		constexpr float FILTER_SEARCH_MIN_WIDTH = 150.0f;                                   // Defines the minimum width in pixels for the search filter to prevent it from becoming unusable.

		// Minimum pixel width for Difficulty filter dropdown (used when window is too narrow) // Comment: Documentation for FILTER_DIFFICULTY_MIN_WIDTH.
		constexpr float FILTER_DIFFICULTY_MIN_WIDTH = 120.0f;                               // Defines the minimum width in pixels for the difficulty dropdown.

		// Minimum pixel width for Shots filter (used when window is too narrow)            // Comment: Documentation for FILTER_SHOTS_MIN_WIDTH.
		constexpr float FILTER_SHOTS_MIN_WIDTH = 150.0f;                                    // Defines the minimum width in pixels for the shots filter.

		// === Dropdowns ===                                                                // Comment: Section for dropdown constants.

		// Width of the tag filter dropdown in Training Packs tab                           // Comment: Documentation for TAG_FILTER_DROPDOWN_WIDTH.
		constexpr float TAG_FILTER_DROPDOWN_WIDTH = 200.0f;                                 // Defines the width in pixels for the tag filter dropdown.

		// === Positions and Spacing ===                                                    // Comment: Section for layout positioning constants.

		// Button group width offset from right edge of window                              // Comment: Documentation for BUTTON_GROUP_OFFSET_FROM_RIGHT.
		constexpr float BUTTON_GROUP_OFFSET_FROM_RIGHT = 280.0f;                            // Defines the offset in pixels to align button groups from the right.

		// Indentation amount for custom pack form section                                  // Comment: Documentation for CUSTOM_PACK_FORM_INDENT.
		constexpr float CUSTOM_PACK_FORM_INDENT = 10.0f;                                    // Defines the indentation in pixels for the custom pack form.

		// === Table Configuration ===                                                      // Comment: Section for table configuration constants.

		// Number of columns in Training Packs table                                        // Comment: Documentation for TABLE_COLUMN_COUNT.
		constexpr int TABLE_COLUMN_COUNT = 5;                                               // Defines the total number of columns in the training packs table.

		// Minimum width for any column in Training Packs table (before dynamic sizing)     // Comment: Documentation for TABLE_MIN_COLUMN_WIDTH.
		constexpr float TABLE_MIN_COLUMN_WIDTH = 40.0f;                                     // Defines the minimum pixel width for table columns.

		// Extra padding added to calculated column widths in Training Packs table          // Comment: Documentation for TABLE_COLUMN_PADDING.
		constexpr float TABLE_COLUMN_PADDING = 20.0f;                                       // Defines extra padding pixels for columns to ensure content fits comfortable.

		// Default width for Actions column in Training Packs table                         // Comment: Documentation for TABLE_ACTIONS_COLUMN_WIDTH.
		constexpr float TABLE_ACTIONS_COLUMN_WIDTH = 200.0f;                                // Defines the default width in pixels for the Actions column.

		// Maximum width cap for Name column in Training Packs table                        // Comment: Documentation for TABLE_NAME_COLUMN_MAX_WIDTH.
		constexpr float TABLE_NAME_COLUMN_MAX_WIDTH = 400.0f;                               // Defines the maximum width in pixels for the Name column to prevent it from taking too much space.

		// === Custom Pack Form - Input Widths ===                                          // Comment: Section for custom pack form input widths.

		// Width of "Training Map Code" input field in custom pack form                     // Comment: Documentation for CUSTOM_PACK_CODE_INPUT_WIDTH.
		constexpr float CUSTOM_PACK_CODE_INPUT_WIDTH = 220.0f;                              // Defines the width in pixels for the pack code input.

		// Width of "Training Map Name" input field in custom pack form                     // Comment: Documentation for CUSTOM_PACK_NAME_INPUT_WIDTH.
		constexpr float CUSTOM_PACK_NAME_INPUT_WIDTH = 300.0f;                              // Defines the width in pixels for the pack name input.

		// Width of "Creator" input field in custom pack form                               // Comment: Documentation for CUSTOM_PACK_CREATOR_INPUT_WIDTH.
		constexpr float CUSTOM_PACK_CREATOR_INPUT_WIDTH = 200.0f;                           // Defines the width in pixels for the creator input.

		// Width of "Tags" input field in custom pack form                                  // Comment: Documentation for CUSTOM_PACK_TAGS_INPUT_WIDTH.
		constexpr float CUSTOM_PACK_TAGS_INPUT_WIDTH = 300.0f;                              // Defines the width in pixels for the tags input.

		// Width of "Video URL" input field in custom pack form                             // Comment: Documentation for CUSTOM_PACK_VIDEO_URL_INPUT_WIDTH.
		constexpr float CUSTOM_PACK_VIDEO_URL_INPUT_WIDTH = 350.0f;                         // Defines the width in pixels for the video URL input.

		// Width of "Notes" multiline text area in custom pack form                         // Comment: Documentation for CUSTOM_PACK_NOTES_INPUT_WIDTH.
		constexpr float CUSTOM_PACK_NOTES_INPUT_WIDTH = 400.0f;                             // Defines the width in pixels for the notes input area.

		// Height of "Notes" multiline text area in custom pack form                        // Comment: Documentation for CUSTOM_PACK_NOTES_INPUT_HEIGHT.
		constexpr float CUSTOM_PACK_NOTES_INPUT_HEIGHT = 60.0f;                             // Defines the height in pixels for the notes input area.

		// === Custom Pack Form - Dropdown Widths ===                                       // Comment: Section for custom pack form dropdown widths.

		// Width of the difficulty dropdown in custom pack form                             // Comment: Documentation for CUSTOM_PACK_DIFFICULTY_DROPDOWN_WIDTH.
		constexpr float CUSTOM_PACK_DIFFICULTY_DROPDOWN_WIDTH = 150.0f;                     // Defines the width in pixels for the difficulty dropdown.

		// === Custom Pack Form - Button Sizes ===                                          // Comment: Section for custom pack form button sizes.

		// Width of "Add Pack" button in custom pack form                                   // Comment: Documentation for CUSTOM_PACK_ADD_BUTTON_WIDTH.
		constexpr float CUSTOM_PACK_ADD_BUTTON_WIDTH = 100.0f;                              // Defines the width in pixels for the "Add Pack" button.

		// Height of "Add Pack" button in custom pack form (0 = auto)                       // Comment: Documentation for CUSTOM_PACK_ADD_BUTTON_HEIGHT.
		constexpr float CUSTOM_PACK_ADD_BUTTON_HEIGHT = 0.0f;                               // Defines the height in pixels for the "Add Pack" button (0 lets ImGui decide).

		// Width of "Clear" button in custom pack form                                      // Comment: Documentation for CUSTOM_PACK_CLEAR_BUTTON_WIDTH.
		constexpr float CUSTOM_PACK_CLEAR_BUTTON_WIDTH = 80.0f;                             // Defines the width in pixels for the "Clear" button.

		// Height of "Clear" button in custom pack form (0 = auto)                          // Comment: Documentation for CUSTOM_PACK_CLEAR_BUTTON_HEIGHT.
		constexpr float CUSTOM_PACK_CLEAR_BUTTON_HEIGHT = 0.0f;                             // Defines the height in pixels for the "Clear" button (0 lets ImGui decide).

		// === Shot Count Ranges ===                                                        // Comment: Section for shot count constants.

		// Minimum value for "Min Shots" filter slider in Training Packs tab                // Comment: Documentation for FILTER_MIN_SHOTS_MIN.
		constexpr int FILTER_MIN_SHOTS_MIN = 0;                                             // Defines the lower bound (0 shots) for the filter slider.

		// Maximum value for "Min Shots" filter slider in Training Packs tab                // Comment: Documentation for FILTER_MIN_SHOTS_MAX.
		constexpr int FILTER_MIN_SHOTS_MAX = 50;                                            // Defines the upper bound (50 shots) for the filter slider.

		// Minimum value for shot count slider in custom pack creation form                 // Comment: Documentation for CUSTOM_PACK_SHOTS_MIN.
		constexpr int CUSTOM_PACK_SHOTS_MIN = 1;                                            // Defines the lower bound (1 shot) for the custom pack slider.

		// Maximum value for shot count slider in custom pack creation form                 // Comment: Documentation for CUSTOM_PACK_SHOTS_MAX.
		constexpr int CUSTOM_PACK_SHOTS_MAX = 50;                                           // Defines the upper bound (50 shots) for the custom pack slider.

		// === Validation Constants ===                                                     // Comment: Section for validation constants.

		// Expected character length for properly formatted training pack code              // Comment: Documentation for PACK_CODE_EXPECTED_LENGTH.
		constexpr int PACK_CODE_EXPECTED_LENGTH = 19;                                       // Defines the exact length of a formatted pack code (XXXX-XXXX-XXXX-XXXX).

		// Position of first dash in training pack code (0-indexed)                         // Comment: Documentation for PACK_CODE_DASH_POSITION_1.
		constexpr int PACK_CODE_DASH_POSITION_1 = 4;                                        // Defines the index of the first hyphen in the pack code.

		// Position of second dash in training pack code (0-indexed)                        // Comment: Documentation for PACK_CODE_DASH_POSITION_2.
		constexpr int PACK_CODE_DASH_POSITION_2 = 9;                                        // Defines the index of the second hyphen in the pack code.

		// Position of third dash in training pack code (0-indexed)                         // Comment: Documentation for PACK_CODE_DASH_POSITION_3.
		constexpr int PACK_CODE_DASH_POSITION_3 = 14;                                       // Defines the index of the third hyphen in the pack code.

		// Maximum characters allowed for raw pack code before formatting                   // Comment: Documentation for PACK_CODE_RAW_MAX_LENGTH.
		constexpr int PACK_CODE_RAW_MAX_LENGTH = 16;                                        // Defines the max length for raw hex characters in a pack code.

		// === Difficulty Badge Colors ===                                                  // Comment: Section for difficulty badge colors.

		// Background color for Unranked/Unknown difficulty badge                           // Comment: Documentation for DIFFICULTY_BADGE_UNRANKED_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_UNRANKED_COLOR = ImVec4(0.75f, 0.75f, 0.75f, 1.0f); // Defines ImVec4 color (Gray) for unranked badge.

		// Background color for Bronze difficulty badge (#925732)                           // Comment: Documentation for DIFFICULTY_BADGE_BRONZE_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_BRONZE_COLOR = ImVec4(0.57f, 0.34f, 0.20f, 1.0f);   // Defines ImVec4 color (Bronze) for bronze badge.

		// Background color for Silver difficulty badge (#91969B)                           // Comment: Documentation for DIFFICULTY_BADGE_SILVER_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_SILVER_COLOR = ImVec4(0.57f, 0.59f, 0.61f, 1.0f);   // Defines ImVec4 color (Silver) for silver badge.

		// Background color for Gold difficulty badge (#C3A11C)                             // Comment: Documentation for DIFFICULTY_BADGE_GOLD_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_GOLD_COLOR = ImVec4(0.76f, 0.63f, 0.11f, 1.0f);     // Defines ImVec4 color (Gold) for gold badge.

		// Background color for Platinum difficulty badge (#43F8F0)                         // Comment: Documentation for DIFFICULTY_BADGE_PLATINUM_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_PLATINUM_COLOR = ImVec4(0.26f, 0.97f, 0.94f, 1.0f); // Defines ImVec4 color (Platinum Cyan) for platinum badge.

		// Background color for Diamond difficulty badge (#00BBFF)                          // Comment: Documentation for DIFFICULTY_BADGE_DIAMOND_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_DIAMOND_COLOR = ImVec4(0.00f, 0.73f, 1.00f, 1.0f);  // Defines ImVec4 color (Diamond Blue) for diamond badge.

		// Background color for Champion difficulty badge (#990099)                         // Comment: Documentation for DIFFICULTY_BADGE_CHAMPION_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_CHAMPION_COLOR = ImVec4(0.60f, 0.00f, 0.60f, 1.0f); // Defines ImVec4 color (Champion Purple) for champion badge.

		// Background color for Grand Champion difficulty badge (#FC272F)                   // Comment: Documentation for DIFFICULTY_BADGE_GRAND_CHAMPION_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_GRAND_CHAMPION_COLOR = ImVec4(0.99f, 0.15f, 0.18f, 1.0f); // Defines ImVec4 color (GC Red) for grand champion badge.

		// Background color for Supersonic Legend difficulty badge (#F6FAFF)                // Comment: Documentation for DIFFICULTY_BADGE_SUPERSONIC_LEGEND_COLOR.
		inline const ImVec4 DIFFICULTY_BADGE_SUPERSONIC_LEGEND_COLOR = ImVec4(0.96f, 0.98f, 1.00f, 1.0f); // Defines ImVec4 color (White/Blue tint) for SSL badge.

		// === UI State Colors ===                                                          // Comment: Section for UI state colors.

		// Text color for section headers in Training Packs tab (bright cyan)               // Comment: Documentation for SECTION_HEADER_TEXT_COLOR.
		inline const ImVec4 SECTION_HEADER_TEXT_COLOR = ImVec4(0.4f, 0.9f, 1.0f, 1.0f);     // Defines ImVec4 color (Cyan) for section headers.

		// Text color for "Last updated" timestamp (brightened gray)                        // Comment: Documentation for LAST_UPDATED_TEXT_COLOR.
		inline const ImVec4 LAST_UPDATED_TEXT_COLOR = ImVec4(0.85f, 0.85f, 0.85f, 1.0f);    // Defines ImVec4 color (Light Gray) for timestamps.

		// Text color for scraping status message (bright yellow)                           // Comment: Documentation for SCRAPING_STATUS_TEXT_COLOR.
		inline const ImVec4 SCRAPING_STATUS_TEXT_COLOR = ImVec4(1.0f, 0.9f, 0.2f, 1.0f);    // Defines ImVec4 color (Yellow) for loading/scraping status.

		// Text color for bag rotation active status message (bright green)                 // Comment: Documentation for BAG_ROTATION_STATUS_COLOR.
		inline const ImVec4 BAG_ROTATION_STATUS_COLOR = ImVec4(0.4f, 1.0f, 0.4f, 1.0f);     // Defines ImVec4 color (Green) for active bag rotation status.

		// Text color for success message "Pack added!" in custom pack form (bright green)  // Comment: Documentation for SUCCESS_MESSAGE_TEXT_COLOR.
		inline const ImVec4 SUCCESS_MESSAGE_TEXT_COLOR = ImVec4(0.4f, 1.0f, 0.4f, 1.0f);    // Defines ImVec4 color (Green) for success messages.

		// Text color for error message in pack code validation (bright red)                // Comment: Documentation for ERROR_MESSAGE_TEXT_COLOR.
		inline const ImVec4 ERROR_MESSAGE_TEXT_COLOR = ImVec4(1.0f, 0.4f, 0.4f, 1.0f);      // Defines ImVec4 color (Red) for error messages.

		// Text color for disabled/info text in custom pack form (brightened gray)          // Comment: Documentation for DISABLED_INFO_TEXT_COLOR.
		inline const ImVec4 DISABLED_INFO_TEXT_COLOR = ImVec4(0.8f, 0.8f, 0.8f, 1.0f);      // Defines ImVec4 color (Gray) for info text.

		// === Button Colors ===                                                            // Comment: Section for button colors.

		// Background color for "In Bag" badge indicator (green)                            // Comment: Documentation for IN_BAG_BUTTON_BG_COLOR.
		inline const ImVec4 IN_BAG_BUTTON_BG_COLOR = ImVec4(0.2f, 0.6f, 0.2f, 1.0f);        // Defines ImVec4 color (Green) for bag indicator.

		// Background color for "Delete" button in Training Packs table (red)               // Comment: Documentation for DELETE_BUTTON_BG_COLOR.
		inline const ImVec4 DELETE_BUTTON_BG_COLOR = ImVec4(0.6f, 0.2f, 0.2f, 1.0f);        // Defines ImVec4 color (Dark Red) for delete button background.

		// Background color for "Delete" button when hovered (lighter red)                  // Comment: Documentation for DELETE_BUTTON_HOVER_COLOR.
		inline const ImVec4 DELETE_BUTTON_HOVER_COLOR = ImVec4(0.8f, 0.3f, 0.3f, 1.0f);     // Defines ImVec4 color (Light Red) for delete button hover state.

	}  // namespace TrainingPackUI                                                          // End of TrainingPackUI sub-namespace.

	// ===================================================================                  // Comment: Visual separator.
	// LOADOUT UI CONSTANTS                                                                 // Comment: Section header for Loadout UI constants.
	// ===================================================================                  // Comment: Visual separator.
	namespace LoadoutUI {                                                                   // Begin the LoadoutUI sub-namespace.

		// === Dropdown Widths ===                                                          // Comment: Section for dropdown widths.

		// Width of the loadout selection dropdown in Loadout Manager tab                   // Comment: Documentation for LOADOUT_SELECTOR_DROPDOWN_WIDTH.
		constexpr float LOADOUT_SELECTOR_DROPDOWN_WIDTH = 220.0f;                           // Defines the width in pixels for the loadout selector.

		// === Timer Durations ===                                                          // Comment: Section for timer constants.

		// Duration (seconds) for "Applying loadout..." status message                      // Comment: Documentation for APPLYING_STATUS_DURATION.
		constexpr float APPLYING_STATUS_DURATION = 5.0f;                                    // Defines the duration in seconds for "Applying" status.

		// Duration (seconds) for "Loadout applied" success message                         // Comment: Documentation for SUCCESS_MESSAGE_DURATION.
		constexpr float SUCCESS_MESSAGE_DURATION = 3.0f;                                    // Defines the duration in seconds for "Success" status.

		// Duration (seconds) for "Loadouts refreshed" message                              // Comment: Documentation for REFRESH_MESSAGE_DURATION.
		constexpr float REFRESH_MESSAGE_DURATION = 2.5f;                                    // Defines the duration in seconds for "Refreshed" status.

		// === Status Message Colors ===                                                    // Comment: Section for status colors.

		// Text color for section header in Loadout Manager tab (bright cyan)               // Comment: Documentation for SECTION_HEADER_COLOR.
		inline const ImVec4 SECTION_HEADER_COLOR = ImVec4(0.4f, 0.9f, 1.0f, 1.0f);          // Defines ImVec4 color (Cyan) for headers.

		// Text color for error/warning messages (bright red)                               // Comment: Documentation for ERROR_WARNING_TEXT_COLOR.
		inline const ImVec4 ERROR_WARNING_TEXT_COLOR = ImVec4(1.0f, 0.6f, 0.6f, 1.0f);      // Defines ImVec4 color (Light Red) for warnings.

		// Text color for "Applying loadout..." status (yellow)                             // Comment: Documentation for APPLYING_STATUS_COLOR.
		inline const ImVec4 APPLYING_STATUS_COLOR = ImVec4(1.0f, 1.0f, 0.0f, 1.0f);         // Defines ImVec4 color (Yellow) for active operations.

		// Text color for success message "Loadout applied" (green)                         // Comment: Documentation for SUCCESS_MESSAGE_COLOR.
		inline const ImVec4 SUCCESS_MESSAGE_COLOR = ImVec4(0.4f, 1.0f, 0.4f, 1.0f);         // Defines ImVec4 color (Green) for success.

		// Text color for "Loadouts refreshed" message (blue)                               // Comment: Documentation for REFRESH_MESSAGE_COLOR.
		inline const ImVec4 REFRESH_MESSAGE_COLOR = ImVec4(0.5f, 0.8f, 1.0f, 1.0f);         // Defines ImVec4 color (Light Blue) for info messages.

	}  // namespace LoadoutUI                                                               // End of LoadoutUI sub-namespace.

	// ===================================================================                  // Comment: Visual separator.
	// QUICK PICKS UI CONSTANTS                                                             // Comment: Section header for Quick Picks UI constants.
	// ===================================================================                  // Comment: Visual separator.
	namespace QuickPicksUI {                                                                // Begin the QuickPicksUI sub-namespace.
		// Width of the Quick Picks table in Training Mode                                  // Comment: Documentation for TABLE_WIDTH.
		constexpr float TABLE_WIDTH = 550.0f;                                               // Defines the width in pixels for the Quick Picks table.

		// Maximum height of the scrollable Quick Picks table                               // Comment: Documentation for TABLE_HEIGHT.
		constexpr float TABLE_HEIGHT = 220.0f;                                              // Defines the max height in pixels for the Quick Picks table before scrolling.

		// Width of the "Name" column in Quick Picks table                                  // Comment: Documentation for COLUMN_NAME_WIDTH.
		constexpr float COLUMN_NAME_WIDTH = 350.0f;                                         // Defines the width in pixels for the Name column.

		// Width of the "Shots" column in Quick Picks table                                 // Comment: Documentation for COLUMN_SHOTS_WIDTH.
		constexpr float COLUMN_SHOTS_WIDTH = 80.0f;                                         // Defines the width in pixels for the Shots column.
	}                                                                                       // End of QuickPicksUI sub-namespace.

}  // namespace UI                                                                          // End of UI namespace.

// ======================================================================================
// FILE: HelpersUI.h
// ======================================================================================
#pragma once                                                                                // Ensures this header file is included only once during compilation.

// UIHelpers.h                                                                              // Comment: Original filename reference.
//                                                                                          // Spacer.
// This file contains "helper functions" that make the UI code cleaner.                     // Comment: Explains the purpose of the file.
// Instead of writing the same 5-10 lines of code over and over for every button or input box, // Comment: Motivation for helpers.
// we can call one of these helpers that does all the work in one line.                     // Comment: Benefit of using helpers.
//                                                                                          // Spacer.
// Think of it like having pre-made "templates" for common UI elements:                     // Comment: Analogy for understanding.
// - Input boxes that automatically validate numbers and save settings                      // Comment: Example 1.
// - Buttons that show helpful tooltips when you hover                                      // Comment: Example 2.
// - Dropdown menus with tooltips                                                           // Comment: Example 3.
// - Status messages that fade out automatically                                            // Comment: Example 4.
//                                                                                          // Spacer.
// This makes the code easier to read, maintain, and less error-prone.                      // Comment: Summary of benefits.

#include "bakkesmod/plugin/bakkesmodplugin.h"                                             // Include BakkesMod SDK for plugin functionality (CVars, GameWrapper).
#include "IMGUI/imgui.h"                                                                    // Include ImGui library for UI types.
#include <string>                                                                           // Include std::string support.

namespace UI {                                                                              // Begin UI namespace.
namespace Helpers {                                                                         // Begin Helpers sub-namespace.

	//                                                                                      // Spacer.
	// SetCVarSafely - Safely saves a setting value to the plugin                           // Comment: Function documentation.
	//                                                                                      // Spacer.
	// This is a utility function that saves values to BakkesMod's settings system (CVars). // Comment: Explanation of function.
	// It includes safety checks to prevent crashes if the settings system isn't available. // Comment: Safety details.
	//                                                                                      // Spacer.
	// Think of CVars like a settings file - when you change a value in the UI, this saves it // Comment: Analogy.
	// so it persists when you restart Rocket League.                                       // Comment: Persistence explanation.
	//                                                                                      // Spacer.
	// Parameters:                                                                          // Comment: Parameter list.
	//   cvarName - The internal name of the setting (e.g., "suitespot_delay_queue_sec")    // Comment: Param 1.
	//   value - The value to save (can be int, bool, float, string, etc.)                  // Comment: Param 2.
	//   cvarManager - The plugin's settings manager (handles the actual saving)            // Comment: Param 3.
	//                                                                                      // Spacer.
	template<typename T>                                                                    // Template definition to allow different types (int, float, string) for 'value'.
	void SetCVarSafely(const char* cvarName, const T& value,                                // Function definition: Takes cvar name and value.
		std::shared_ptr<CVarManagerWrapper> cvarManager,                                    // Parameter: CVarManager pointer.
		std::shared_ptr<GameWrapper> gameWrapper) {                                         // Parameter: GameWrapper pointer.
		// Safety check: Make sure the managers exist                                       // Comment: Explains the check.
		if (!cvarManager || !gameWrapper) return;                                           // If pointers are null, exit immediately to prevent crash.

		// Get the setting                                                                  // Comment: Step description.
		auto cvar = cvarManager->getCvar(cvarName);                                         // specific CVar object by name.
		if (cvar) {                                                                         // Check if the CVar exists.
			// CRITICAL: Force the update to the Game Thread                                // Comment: Thread safety warning.
			// This prevents "Rendering thread exception" when called from UI/Render threads // Comment: Context on crash prevention.
			gameWrapper->SetTimeout([cvar, value](GameWrapper* gw) {                        // Schedule the update on the main game thread using SetTimeout (delay 0).
				// Use a copy of the value and the cvar wrapper inside the lambda           // Comment: Capture details.
				CVarWrapper(cvar).setValue(value);                                          // Set the new value for the CVar.
			}, 0.0f);                                                                       // Delay of 0.0f means "next frame" or "asap on game thread".
		}
	}

	//                                                                                      // Spacer.
	// InputIntWithRange - Creates a "smart" number input box                               // Comment: Function declaration documentation.
	//                                                                                      // Spacer.
	bool InputIntWithRange(                                                                 // Function declaration: Returns true if value changed.
		const char* label,                                                                  // Parameter: Label text for the input.
		int& value,                                                                         // Parameter: Reference to the integer value to modify.
		int minValue,                                                                       // Parameter: Minimum allowed value.
		int maxValue,                                                                       // Parameter: Maximum allowed value.
		float width,                                                                        // Parameter: Width of the input box.
		const char* cvarName,                                                               // Parameter: CVar name to save to (optional).
		std::shared_ptr<CVarManagerWrapper> cvarManager,                                    // Parameter: CVar manager.
		std::shared_ptr<GameWrapper> gameWrapper,                                           // Parameter: Game wrapper.
		const char* tooltip = nullptr,                                                      // Parameter: Tooltip text (optional).
		const char* rangeHint = nullptr                                                     // Parameter: Range hint text (optional).
	);

	//                                                                                      // Spacer.
	// ComboWithTooltip - Creates a dropdown menu with automatic tooltip                    // Comment: Function declaration documentation.
	//                                                                                      // Spacer.
	bool ComboWithTooltip(                                                                  // Function declaration.
		const char* label,                                                                  // Parameter: Label text.
		const char* previewValue,                                                           // Parameter: Currently selected text to display.
		const char* tooltip,                                                                // Parameter: Tooltip text.
		float width = 0.0f                                                                  // Parameter: Width (optional, default 0).
	);

	//                                                                                      // Spacer.
	// ButtonWithTooltip - Creates a button with automatic tooltip                          // Comment: Function declaration documentation.
	//                                                                                      // Spacer.
	bool ButtonWithTooltip(                                                                 // Function declaration.
		const char* label,                                                                  // Parameter: Button text.
		const char* tooltip,                                                                // Parameter: Tooltip text.
		const ImVec2& size = ImVec2(0, 0)                                                   // Parameter: Button size (optional, default auto).
	);

	//                                                                                      // Spacer.
	// ShowStatusMessage - Displays a message that automatically fades out                  // Comment: Function declaration documentation.
	//                                                                                      // Spacer.
	void ShowStatusMessage(                                                                 // Function declaration.
		const std::string& text,                                                            // Parameter: Message text.
		const ImVec4& color,                                                                // Parameter: Text color.
		float& timer,                                                                       // Parameter: Reference to timer variable (decremented inside).
		float deltaTime                                                                     // Parameter: Time passed since last frame.
	);

	//                                                                                      // Spacer.
	// ShowStatusMessageWithFade - Status message with smooth alpha fade-out                // Comment: Function declaration documentation.
	//                                                                                      // Spacer.
	void ShowStatusMessageWithFade(                                                         // Function declaration.
		const std::string& text,                                                            // Parameter: Message text.
		const ImVec4& baseColor,                                                            // Parameter: Base color (alpha will change).
		float& timer,                                                                       // Parameter: Reference to timer.
		float maxDuration,                                                                  // Parameter: Total duration for fade calc.
		float deltaTime                                                                     // Parameter: Time delta.
	);

	//                                                                                      // Spacer.
	// CheckboxWithCVar - Creates a checkbox that automatically saves to settings           // Comment: Function declaration documentation.
	//                                                                                      // Spacer.
	bool CheckboxWithCVar(                                                                  // Function declaration.
		const char* label,                                                                  // Parameter: Checkbox label.
		bool& value,                                                                        // Parameter: Reference to boolean value.
		const char* cvarName,                                                               // Parameter: CVar name to save to.
		std::shared_ptr<CVarManagerWrapper> cvarManager,                                    // Parameter: CVar manager.
		std::shared_ptr<GameWrapper> gameWrapper,                                           // Parameter: Game wrapper.
		const char* tooltip = nullptr                                                       // Parameter: Tooltip text (optional).
	);

	//                                                                                      // Spacer.
	// InputTextWithTooltip - Creates a text input box with automatic tooltip               // Comment: Function declaration documentation.
	//                                                                                      // Spacer.
	// Creates a text input field that automatically shows a tooltip when you hover over it.// Comment: Description.
	// Cleaner than writing the input and tooltip code separately.                          // Comment: Motivation.
	//                                                                                      // Spacer.
	// Example: "Training Map Code" input with tooltip "Enter the code (e.g., 555F-7503-BBB9-E1E3)" // Comment: Example usage.
	//                                                                                      // Spacer.
	// Parameters:                                                                          // Comment: Parameter list.
	//   label - What to display next to the input box                                      // Comment: Param 1.
	//   buf - Character buffer for the text being edited                                   // Comment: Param 2.
	//   bufSize - Size of the buffer (how many characters it can hold)                     // Comment: Param 3.
	//   tooltip - Help text displayed when hovering                                        // Comment: Param 4.
	//   width - How wide the input box should be in pixels (0 = use default width)         // Comment: Param 5.
	//   flags - Special input options (optional - see ImGui docs)                          // Comment: Param 6.
	//                                                                                      // Spacer.
	// Returns: true if the text was modified                                               // Comment: Return value.
	//                                                                                      // Spacer.
	// Usage:                                                                               // Comment: Usage example.
	//   char mapCode[64] = "";                                                             // Comment: Code snippet.
	//   if (InputTextWithTooltip("Code", mapCode, sizeof(mapCode),                         // Comment: Code snippet.
	//                            "Enter pack code", 220.0f)) {                             // Comment: Code snippet.
	//       // Text was changed                                                            // Comment: Code snippet.
	//   }                                                                                  // Comment: Code snippet.
	//                                                                                      // Spacer.
	bool InputTextWithTooltip(                                                              // Function declaration.
		const char* label,                                                                  // Parameter: Label.
		char* buf,                                                                          // Parameter: Buffer.
		size_t bufSize,                                                                     // Parameter: Buffer size.
		const char* tooltip,                                                                // Parameter: Tooltip.
		float width = 0.0f,                                                                 // Parameter: Width.
		ImGuiInputTextFlags flags = 0                                                       // Parameter: Flags.
	);

} // namespace Helpers                                                                      // End Helpers namespace.
} // namespace UI                                                                           // End UI namespace.

// ======================================================================================
// FILE: HelpersUI.cpp
// ======================================================================================
#include "pch.h"                                                                            // Include precompiled header for faster builds.
#include "HelpersUI.h"                                                                      // Include the corresponding header file.
#include <algorithm>  // for std::clamp                                                     // Include algorithm header for std::clamp function.

namespace UI {                                                                              // Begin UI namespace.
namespace Helpers {                                                                         // Begin Helpers sub-namespace.

	//                                                                                      // Spacer.
	// InputIntWithRange - Smart number input with automatic validation and saving          // Comment: Function header.
	//                                                                                      // Spacer.
	bool InputIntWithRange(                                                                 // Function definition start.
		const char* label,                                                                  // Parameter: Label.
		int& value,                                                                         // Parameter: Value reference.
		int minValue,                                                                       // Parameter: Min.
		int maxValue,                                                                       // Parameter: Max.
		float width,                                                                        // Parameter: Width.
		const char* cvarName,                                                               // Parameter: CVar name.
		std::shared_ptr<CVarManagerWrapper> cvarManager,                                    // Parameter: CVar manager.
		std::shared_ptr<GameWrapper> gameWrapper,                                           // Parameter: Game wrapper.
		const char* tooltip,                                                                // Parameter: Tooltip.
		const char* rangeHint)                                                              // Parameter: Range hint.
	{
		// Set how wide the input box should be (if a width was specified)                  // Comment: Logic explanation.
		// This is like saying "make this input box 220 pixels wide"                        // Comment: Analogy.
		if (width > 0.0f) {                                                                 // Check if custom width is requested.
			ImGui::SetNextItemWidth(width);                                                 // Apply the custom width to the next ImGui item.
		}

		// Show the actual input box and check if the user changed the number               // Comment: Logic explanation.
		bool changed = ImGui::InputInt(label, &value);                                      // Display InputInt widget and store return value (true if changed).
		if (changed) {                                                                      // If the value was modified...
			// User typed a new number - make sure it's in the valid range                  // Comment: Logic explanation.
			// Like making sure someone can't set a delay to -50 seconds or 9999 seconds    // Comment: Analogy.
			value = std::clamp(value, minValue, maxValue);                                  // Clamp the value between min and max.

			// Save the new value to the plugin's settings file                             // Comment: Logic explanation.
			// This is what makes the setting persist when you restart the game             // Comment: Context.
			if (cvarName && cvarManager && gameWrapper) {                                   // Check if persistence parameters are valid.
				SetCVarSafely(cvarName, value, cvarManager, gameWrapper);                   // Save the value to CVar safely on the game thread.
			}
		}

		// Show the range hint next to the input (like "0-300s")                            // Comment: Logic explanation.
		// This reminds users what values are allowed                                       // Comment: Purpose.
		if (rangeHint) {                                                                    // If a range hint string is provided...
			ImGui::SameLine();                                                              // Move cursor to the same line as the input box.
			ImGui::TextDisabled(rangeHint);                                                 // Display the hint text in a disabled (grayed out) style.
		}

		// If there's a tooltip, show it when the user hovers their mouse                   // Comment: Logic explanation.
		// This is the "helpful hint" feature                                               // Comment: Purpose.
		if (tooltip && ImGui::IsItemHovered()) {                                            // If tooltip text exists and mouse is hovering the item...
			ImGui::SetTooltip("%s", tooltip);                                               // Display the tooltip.
		}

		return changed;                                                                     // Return true if value changed, false otherwise.
	}

	//                                                                                      // Spacer.
	// ComboWithTooltip - Dropdown menu with automatic help tooltip                         // Comment: Function header.
	//                                                                                      // Spacer.
	bool ComboWithTooltip(                                                                  // Function definition.
		const char* label,                                                                  // Parameter: Label.
		const char* previewValue,                                                           // Parameter: Preview text.
		const char* tooltip,                                                                // Parameter: Tooltip.
		float width)                                                                        // Parameter: Width.
	{
		// Set how wide the dropdown should be (if a width was specified)                   // Comment: Logic explanation.
		if (width > 0.0f) {                                                                 // Check if width > 0.
			ImGui::SetNextItemWidth(width);                                                 // Set width for next item.
		}

		// Start the dropdown menu                                                          // Comment: Logic explanation.
		// BeginCombo returns true if the dropdown is open (user clicked on it)             // Comment: Details.
		bool isOpen = ImGui::BeginCombo(label, previewValue);                               // Start the combo box widget.

		// Show tooltip when hovering over the dropdown                                     // Comment: Logic explanation.
		// This works whether the dropdown is open or closed                                // Comment: Details.
		if (tooltip && ImGui::IsItemHovered()) {                                            // If tooltip exists and item hovered...
			ImGui::SetTooltip("%s", tooltip);                                               // Show tooltip.
		}

		// Return whether the dropdown is open                                              // Comment: Logic explanation.
		// If true, the caller needs to add items with ImGui::Selectable() and call ImGui::EndCombo() // Comment: Usage instruction.
		return isOpen;                                                                      // Return state.
	}

	//                                                                                      // Spacer.
	// ButtonWithTooltip - Button with automatic help tooltip                               // Comment: Function header.
	//                                                                                      // Spacer.
	bool ButtonWithTooltip(                                                                 // Function definition.
		const char* label,                                                                  // Parameter: Label.
		const char* tooltip,                                                                // Parameter: Tooltip.
		const ImVec2& size)                                                                 // Parameter: Size.
	{
		// Create the button and check if it was clicked                                    // Comment: Logic explanation.
		bool clicked = ImGui::Button(label, size);                                          // Draw button and capture click state.

		// Show tooltip when hovering over the button                                       // Comment: Logic explanation.
		// This lets users know what the button does before clicking                        // Comment: Details.
		if (tooltip && ImGui::IsItemHovered()) {                                            // If tooltip exists and hovered...
			ImGui::SetTooltip("%s", tooltip);                                               // Show tooltip.
		}

		// Return whether the button was clicked                                            // Comment: Logic explanation.
		return clicked;                                                                     // Return click state.
	}

	//                                                                                      // Spacer.
	// ShowStatusMessage - Auto-fading status message                                       // Comment: Function header.
	//                                                                                      // Spacer.
	void ShowStatusMessage(                                                                 // Function definition.
		const std::string& text,                                                            // Parameter: Text.
		const ImVec4& color,                                                                // Parameter: Color.
		float& timer,                                                                       // Parameter: Timer ref.
		float deltaTime)                                                                    // Parameter: Delta time.
	{
		// Only show the message if there's time remaining on the timer                     // Comment: Logic explanation.
		// Once timer hits 0, the message disappears                                        // Comment: Details.
		if (timer > 0.0f && !text.empty()) {                                                // Check if timer active and text not empty.
			// Add some spacing before the message for visual separation                    // Comment: Logic explanation.
			ImGui::Spacing();                                                               // Insert vertical spacing.

			// Display the message in the specified color                                   // Comment: Logic explanation.
			// %s means "insert the text here"                                              // Comment: Details.
			ImGui::TextColored(color, "%s", text.c_str());                                  // Draw colored text.

			// Count down the timer using the time that passed since last frame             // Comment: Logic explanation.
			// deltaTime is usually 0.016 seconds (1/60th of a second at 60 FPS)            // Comment: Context.
			timer -= deltaTime;                                                             // Decrement timer.

			// If timer went negative, clamp it to exactly 0                                // Comment: Logic explanation.
			// This prevents weird negative timer values                                    // Comment: Safety.
			if (timer <= 0.0f) {                                                            // Check underflow.
				timer = 0.0f;                                                               // Clamp to 0.
			}
		}
	}

	//                                                                                      // Spacer.
	// ShowStatusMessageWithFade - Status message with smooth transparency fade             // Comment: Function header.
	//                                                                                      // Spacer.
	void ShowStatusMessageWithFade(                                                         // Function definition.
		const std::string& text,                                                            // Parameter: Text.
		const ImVec4& baseColor,                                                            // Parameter: Base color.
		float& timer,                                                                       // Parameter: Timer ref.
		float maxDuration,                                                                  // Parameter: Max duration.
		float deltaTime)                                                                    // Parameter: Delta time.
	{
		// Only show the message if there's time remaining                                  // Comment: Logic explanation.
		if (timer > 0.0f && !text.empty()) {                                                // Check condition.
			// Add some spacing for visual separation                                       // Comment: Logic explanation.
			ImGui::Spacing();                                                               // Insert spacing.

			// Calculate how transparent the text should be based on remaining time         // Comment: Logic explanation.
			// If timer = maxDuration (full time left), alpha = 1.0 (fully visible)         // Comment: Math explanation.
			// If timer = 0 (no time left), alpha = 0.0 (fully transparent)                 // Comment: Math explanation.
			// This creates a smooth fade-out effect                                        // Comment: Result.
			float alpha = timer / maxDuration;                                              // Calculate alpha value.

			// Create a faded version of the color with the calculated alpha                // Comment: Logic explanation.
			// Keep RGB the same, just change the transparency                              // Comment: Details.
			ImVec4 fadedColor = ImVec4(baseColor.x, baseColor.y, baseColor.z, alpha);       // Construct new color with modified alpha.

			// Display the message with the faded color                                     // Comment: Logic explanation.
			ImGui::TextColored(fadedColor, "%s", text.c_str());                             // Draw text.

			// Count down the timer                                                         // Comment: Logic explanation.
			timer -= deltaTime;                                                             // Decrement timer.

			// Clamp timer to 0 if it went negative                                         // Comment: Logic explanation.
			if (timer <= 0.0f) {                                                            // Check underflow.
				timer = 0.0f;                                                               // Clamp to 0.
			}
		}
	}

	//                                                                                      // Spacer.
	// CheckboxWithCVar - Checkbox that automatically saves to settings                     // Comment: Function header.
	//                                                                                      // Spacer.
	bool CheckboxWithCVar(                                                                  // Function definition.
		const char* label,                                                                  // Parameter: Label.
		bool& value,                                                                        // Parameter: Value ref.
		const char* cvarName,                                                               // Parameter: CVar name.
		std::shared_ptr<CVarManagerWrapper> cvarManager,                                    // Parameter: CVar manager.
		std::shared_ptr<GameWrapper> gameWrapper,                                           // Parameter: Game wrapper.
		const char* tooltip)                                                                // Parameter: Tooltip.
	{
		// Create the checkbox and check if it was toggled                                  // Comment: Logic explanation.
		bool toggled = ImGui::Checkbox(label, &value);                                      // Draw checkbox and capture toggle state.

		if (toggled) {                                                                      // If value changed...
			// User clicked the checkbox - save the new value to settings                   // Comment: Logic explanation.
			// This makes the checkbox state persist when you restart the game              // Comment: Persistence.
			if (cvarName && cvarManager && gameWrapper) {                                   // Check validity.
				SetCVarSafely(cvarName, value, cvarManager, gameWrapper);                   // Save to CVar.
			}
		}

		// Show tooltip when hovering over the checkbox                                     // Comment: Logic explanation.
		if (tooltip && ImGui::IsItemHovered()) {                                            // Check hover.
			ImGui::SetTooltip("%s", tooltip);                                               // Show tooltip.
		}

		// Return whether the checkbox was toggled                                          // Comment: Logic explanation.
		return toggled;                                                                     // Return state.
	}

	//                                                                                      // Spacer.
	// InputTextWithTooltip - Text input box with automatic tooltip                         // Comment: Function header.
	//                                                                                      // Spacer.
	bool InputTextWithTooltip(                                                              // Function definition.
		const char* label,                                                                  // Parameter: Label.
		char* buf,                                                                          // Parameter: Buffer.
		size_t bufSize,                                                                     // Parameter: Buffer size.
		const char* tooltip,                                                                // Parameter: Tooltip.
		float width,                                                                        // Parameter: Width.
		ImGuiInputTextFlags flags)                                                          // Parameter: Flags.
	{
		// Set how wide the input box should be (if a width was specified)                  // Comment: Logic explanation.
		if (width > 0.0f) {                                                                 // Check width.
			ImGui::SetNextItemWidth(width);                                                 // Set next width.
		}

		// Show the text input box and check if the user modified the text                  // Comment: Logic explanation.
		bool changed = ImGui::InputText(label, buf, bufSize, flags);                        // Draw InputText.

		// Show tooltip when hovering over the input box                                    // Comment: Logic explanation.
		// Helps users understand what to type                                              // Comment: Purpose.
		if (tooltip && ImGui::IsItemHovered()) {                                            // Check hover.
			ImGui::SetTooltip("%s", tooltip);                                               // Show tooltip.
		}

		// Return whether the text was modified                                             // Comment: Logic explanation.
		return changed;                                                                     // Return changed state.
	}

} // namespace Helpers                                                                      // End Helpers.
} // namespace UI                                                                           // End UI.

// ======================================================================================
// FILE: StatusMessageUI.h
// ======================================================================================
#pragma once                                                                                // Ensures header is included only once.

// StatusMessage.h                                                                          // Comment: Original filename.
//                                                                                          // Spacer.
// A reusable class for displaying temporary or dismissible status messages in the UI.      // Comment: Class purpose.
// This replaces 3 different timer/boolean patterns found in LoadoutUI, SettingsUI, and TrainingPackUI. // Comment: Refactoring context.
//                                                                                          // Spacer.
// Purpose: Provides a single, consistent way to show feedback messages to users            // Comment: Goal.
// (like "Loadout applied!", "Pack added!", "Error: invalid code") across all UI components.// Comment: Examples.
//                                                                                          // Spacer.
// Think of it like a notification system - you can show a message, pick how long it shows, // Comment: Analogy.
// and choose whether it fades out automatically or waits for the user to dismiss it.       // Comment: Functionality.
//                                                                                          // Spacer.
// Example Usage:                                                                           // Comment: Usage section.
//   // In your UI class header file:                                                       // Comment: Context.
//   UI::StatusMessage statusMsg;                                                           // Comment: Code snippet.
//                                                                                          // Spacer.
//   // When something happens (like saving successfully):                                  // Comment: Context.
//   statusMsg.ShowSuccess("Loadout applied!", 3.0f);                                       // Comment: Code snippet.
//                                                                                          // Spacer.
//   // Every frame in your render function:                                                // Comment: Context.
//   statusMsg.Render(ImGui::GetIO().DeltaTime);                                            // Comment: Code snippet.
//                                                                                          // Spacer.
// The class handles all the timer logic, color management, and display automatically.      // Comment: Benefit.

#include "IMGUI/imgui.h"                                                                    // Include ImGui for UI rendering.
#include <string>                                                                           // Include std::string.

namespace UI {                                                                              // Begin UI namespace.

class StatusMessage {                                                                       // Class definition.
public:                                                                                     // Public interface.
	//                                                                                      // Spacer.
	// DisplayMode - How the message should appear and disappear                            // Comment: Enum documentation.
	//                                                                                      // Spacer.
	// This controls the "lifecycle" of the message - how long it shows and how it hides.   // Comment: Enum purpose.
	//                                                                                      // Spacer.
	enum class DisplayMode {                                                                // Enum definition.
		// Timer - Shows for a set duration, then disappears instantly                      // Comment: Timer option.
		// Like a toast notification that just vanishes after 3 seconds                     // Comment: Timer analogy.
		// Best for: Quick confirmations like "Saved!" or "Refreshed"                       // Comment: Timer use case.
		Timer,                                                                              // Timer enum value.

		// TimerWithFade - Shows for a set duration, gradually fading to transparent        // Comment: Fade option.
		// The message starts fully visible, then slowly becomes see-through before vanishing // Comment: Fade behavior.
		// Best for: Success messages that don't need immediate attention                   // Comment: Fade use case.
		TimerWithFade,                                                                      // Fade enum value.

		// ManualDismiss - Stays visible until user clicks a "Dismiss" button               // Comment: Manual option.
		// Won't go away on its own - the user must actively close it                       // Comment: Manual behavior.
		// Best for: Important errors or warnings that need acknowledgment                  // Comment: Manual use case.
		ManualDismiss                                                                       // Manual enum value.
	};

	//                                                                                      // Spacer.
	// Type - The kind of message (determines the default color)                            // Comment: Enum documentation.
	//                                                                                      // Spacer.
	// This helps categorize messages and automatically picks an appropriate color.         // Comment: Enum purpose.
	// Think of it like traffic lights: green = good, red = bad, yellow = warning.          // Comment: Analogy.
	//                                                                                      // Spacer.
	enum class Type {                                                                       // Enum definition.
		Success,  // Something worked! (Green color)                                        // Comment: Success option.
		Error,    // Something failed! (Red color)                                          // Comment: Error option.
		Warning,  // Be careful! (Yellow color)                                             // Comment: Warning option.
		Info      // Just letting you know... (Blue color)                                  // Comment: Info option.
	};

	// Constructor - creates an empty status message (nothing shows until you call Show...) // Comment: Constructor doc.
	StatusMessage() = default;                                                              // Default constructor.

	//                                                                                      // Spacer.
	// Show - Display a message with automatic color based on type                          // Comment: Method documentation.
	//                                                                                      // Spacer.
	// This is the main method for showing messages. It picks the color automatically       // Comment: Method details.
	// based on whether it's a success, error, warning, or info message.                    // Comment: Method details.
	//                                                                                      // Spacer.
	// Parameters:                                                                          // Comment: Params.
	//   text - The message to display (e.g., "Loadout applied successfully!")              // Comment: Param 1.
	//   duration - How many seconds to show it (ignored if mode is ManualDismiss)          // Comment: Param 2.
	//   mode - How it should appear/disappear (Timer, TimerWithFade, or ManualDismiss)     // Comment: Param 3.
	//   type - What kind of message it is (Success, Error, Warning, or Info)               // Comment: Param 4.
	//                                                                                      // Spacer.
	// Example:                                                                             // Comment: Example.
	//   statusMsg.Show("Settings saved!", 3.0f, DisplayMode::Timer, Type::Success);        // Comment: Code snippet.
	//                                                                                      // Spacer.
	void Show(const std::string& text, float duration, DisplayMode mode, Type type);        // Method declaration.

	//                                                                                      // Spacer.
	// ShowCustom - Display a message with a custom color                                   // Comment: Method documentation.
	//                                                                                      // Spacer.
	// Use this when you want a specific color that doesn't match the standard types.       // Comment: Method details.
	// For example, if you want purple text or a specific shade of blue.                    // Comment: Method details.
	//                                                                                      // Spacer.
	// Parameters:                                                                          // Comment: Params.
	//   text - The message to display                                                      // Comment: Param 1.
	//   color - Custom ImVec4 color (RGBA values from 0.0 to 1.0)                          // Comment: Param 2.
	//   duration - How many seconds to show it (ignored if mode is ManualDismiss)          // Comment: Param 3.
	//   mode - How it should appear/disappear                                              // Comment: Param 4.
	//                                                                                      // Spacer.
	// Example:                                                                             // Comment: Example.
	//   ImVec4 purple = ImVec4(0.8f, 0.4f, 1.0f, 1.0f);                                    // Comment: Code snippet.
	//   statusMsg.ShowCustom("Custom message!", purple, 5.0f, DisplayMode::TimerWithFade); // Comment: Code snippet.
	//                                                                                      // Spacer.
	void ShowCustom(const std::string& text, const ImVec4& color, float duration, DisplayMode mode); // Method declaration.

	//                                                                                      // Spacer.
	// Convenience methods - Shortcuts for common message types                             // Comment: Section header.
	//                                                                                      // Spacer.
	// These are "helper methods" that make showing messages even easier.                   // Comment: Section details.
	// Instead of typing out all the parameters, you can just call ShowSuccess(...)         // Comment: Section details.
	// and it automatically picks sensible defaults.                                        // Comment: Section details.
	//                                                                                      // Spacer.

	// ShowSuccess - Show a green success message                                           // Comment: Method documentation.
	// Defaults: 3 seconds, simple timer (instant hide)                                     // Comment: Defaults.
	// Example: statusMsg.ShowSuccess("Pack added!");                                       // Comment: Example.
	void ShowSuccess(const std::string& text, float duration = 3.0f,                        // Method declaration with defaults.
		DisplayMode mode = DisplayMode::Timer);                                             // ...

	// ShowError - Show a red error message                                                 // Comment: Method documentation.
	// Defaults: 3 seconds, manual dismiss (user must click "Dismiss")                      // Comment: Defaults.
	// Example: statusMsg.ShowError("Invalid pack code format");                            // Comment: Example.
	void ShowError(const std::string& text, float duration = 3.0f,                          // Method declaration with defaults.
		DisplayMode mode = DisplayMode::ManualDismiss);                                     // ...

	// ShowWarning - Show a yellow warning message                                          // Comment: Method documentation.
	// Defaults: 5 seconds (longer than success), simple timer                              // Comment: Defaults.
	// Example: statusMsg.ShowWarning("Applying loadout...");                               // Comment: Example.
	void ShowWarning(const std::string& text, float duration = 5.0f,                        // Method declaration with defaults.
		DisplayMode mode = DisplayMode::Timer);                                             // ...

	// ShowInfo - Show a blue informational message                                         // Comment: Method documentation.
	// Defaults: 2.5 seconds, fade effect (looks smooth)                                    // Comment: Defaults.
	// Example: statusMsg.ShowInfo("Loadouts refreshed");                                   // Comment: Example.
	void ShowInfo(const std::string& text, float duration = 2.5f,                           // Method declaration with defaults.
		DisplayMode mode = DisplayMode::TimerWithFade);                                     // ...

	//                                                                                      // Spacer.
	// Render - Display the message on screen                                               // Comment: Method documentation.
	//                                                                                      // Spacer.
	// IMPORTANT: You must call this EVERY FRAME in your UI render function!                // Comment: Warning.
	// This is what actually draws the message and handles the timer countdown.             // Comment: Detail.
	//                                                                                      // Spacer.
	// If you don't call this, the message won't show up.                                   // Comment: Consequence.
	// Think of it like watering a plant - you need to do it regularly.                     // Comment: Analogy.
	//                                                                                      // Spacer.
	// Parameters:                                                                          // Comment: Params.
	//   deltaTime - Time since last frame in seconds (use ImGui::GetIO().DeltaTime)        // Comment: Param 1.
	//                                                                                      // Spacer.
	// Example in your render function:                                                     // Comment: Example.
	//   void RenderMyUI() {                                                                // Comment: Code snippet.
	//       // ... your other UI code ...                                                  // Comment: Code snippet.
	//       statusMsg.Render(ImGui::GetIO().DeltaTime);                                    // Comment: Code snippet.
	//   }                                                                                  // Comment: Code snippet.
	//                                                                                      // Spacer.
	void Render(float deltaTime);                                                           // Method declaration.

	//                                                                                      // Spacer.
	// Clear - Immediately hide the message                                                 // Comment: Method documentation.
	//                                                                                      // Spacer.
	// Use this when you want to force the message to disappear right now,                  // Comment: Method details.
	// regardless of its timer or mode. Like pressing a "cancel" button.                    // Comment: Method details.
	//                                                                                      // Spacer.
	// Example:                                                                             // Comment: Example.
	//   if (userClickedCancel) {                                                           // Comment: Code snippet.
	//       statusMsg.Clear();  // Hide the message instantly                              // Comment: Code snippet.
	//   }                                                                                  // Comment: Code snippet.
	//                                                                                      // Spacer.
	void Clear();                                                                           // Method declaration.

	//                                                                                      // Spacer.
	// IsVisible - Check if a message is currently showing                                  // Comment: Method documentation.
	//                                                                                      // Spacer.
	// Returns true if there's a message on screen, false if it's hidden.                   // Comment: Method details.
	// Useful for checking if you need to show a new message or if one is already active.   // Comment: Method details.
	//                                                                                      // Spacer.
	// Example:                                                                             // Comment: Example.
	//   if (!statusMsg.IsVisible()) {                                                      // Comment: Code snippet.
	//       statusMsg.ShowSuccess("New message!");                                         // Comment: Code snippet.
	//   }                                                                                  // Comment: Code snippet.
	//                                                                                      // Spacer.
	bool IsVisible() const;                                                                 // Method declaration.

private:                                                                                    // Private implementation.
	// Internal state - these track what message is showing and how                         // Comment: Section details.
	std::string text_;          // The current message text                                 // Member: Message text.
	ImVec4 color_;              // The current message color (RGBA)                         // Member: Message color.
	float timer_;               // Countdown timer (seconds remaining)                      // Member: Timer.
	float maxDuration_;         // Original duration (used for fade calculation)            // Member: Max duration.
	DisplayMode mode_;          // How the message should behave                            // Member: Display mode.
	bool visible_;              // Is the message currently showing?                        // Member: Visibility flag.

	// Helper method to get the standard color for a message type                           // Comment: Method documentation.
	// (e.g., Type::Success returns green, Type::Error returns red)                         // Comment: Details.
	ImVec4 GetColorForType(Type type) const;                                                // Method declaration.
};

} // namespace UI                                                                           // End namespace UI.

// ======================================================================================
// FILE: StatusMessageUI.cpp
// ======================================================================================
#include "pch.h"                                                                            // Include precompiled header.
#include "StatusMessageUI.h"                                                                // Include header.

namespace UI {                                                                              // Begin UI namespace.

//                                                                                          // Spacer.
// Show - Display a message with automatic color based on type                              // Comment: Method implementation.
//                                                                                          // Spacer.
// This is the main "entry point" for showing messages. You tell it what to say,            // Comment: Details.
// how long to show it, how it should behave, and what kind of message it is.               // Comment: Details.
// The class automatically picks the right color based on the type.                         // Comment: Details.
//                                                                                          // Spacer.
void StatusMessage::Show(const std::string& text, float duration, DisplayMode mode, Type type) // Method definition.
{
	text_ = text;                                                                           // Store the message text.
	color_ = GetColorForType(type);                                                         // Determine color based on type.
	timer_ = duration;                                                                      // Set the timer duration.
	maxDuration_ = duration;  // Store original duration for fade calculations              // Store max duration for alpha calc.
	mode_ = mode;                                                                           // Store display mode.
	visible_ = true;                                                                        // Set visible flag to true.
}

//                                                                                          // Spacer.
// ShowCustom - Display a message with a custom color                                       // Comment: Method implementation.
//                                                                                          // Spacer.
// Same as Show(), but lets you pick your own color instead of using the                    // Comment: Details.
// standard Success/Error/Warning/Info colors.                                              // Comment: Details.
//                                                                                          // Spacer.
void StatusMessage::ShowCustom(const std::string& text, const ImVec4& color, float duration, DisplayMode mode) // Method definition.
{
	text_ = text;                                                                           // Store message text.
	color_ = color;                                                                         // Store custom color.
	timer_ = duration;                                                                      // Set timer.
	maxDuration_ = duration;                                                                // Set max duration.
	mode_ = mode;                                                                           // Set mode.
	visible_ = true;                                                                        // Set visible flag.
}

//                                                                                          // Spacer.
// Convenience methods - Quick shortcuts for common message types                           // Comment: Section implementation.
//                                                                                          // Spacer.
// These save you from typing out all the parameters every time.                            // Comment: Details.
// Just call ShowSuccess("Done!") instead of Show("Done!", 3.0f, Timer, Success).           // Comment: Details.
//                                                                                          // Spacer.

void StatusMessage::ShowSuccess(const std::string& text, float duration, DisplayMode mode)  // Method definition.
{
	Show(text, duration, mode, Type::Success);                                              // Call Show with Success type.
}

void StatusMessage::ShowError(const std::string& text, float duration, DisplayMode mode)    // Method definition.
{
	Show(text, duration, mode, Type::Error);                                                // Call Show with Error type.
}

void StatusMessage::ShowWarning(const std::string& text, float duration, DisplayMode mode)  // Method definition.
{
	Show(text, duration, mode, Type::Warning);                                              // Call Show with Warning type.
}

void StatusMessage::ShowInfo(const std::string& text, float duration, DisplayMode mode)     // Method definition.
{
	Show(text, duration, mode, Type::Info);                                                 // Call Show with Info type.
}

//                                                                                          // Spacer.
// Render - Display the message on screen and handle timer logic                            // Comment: Method implementation.
//                                                                                          // Spacer.
// IMPORTANT: Call this EVERY FRAME in your UI render function!                             // Comment: Warning.
// This is where all the magic happens - it draws the message and manages the timer.        // Comment: Details.
//                                                                                          // Spacer.
// How it works:                                                                            // Comment: Logic flow.
// 1. If not visible, do nothing (message is hidden)                                        // Comment: Step 1.
// 2. If visible, countdown the timer using deltaTime (time since last frame)               // Comment: Step 2.
// 3. Display the message based on the mode:                                                // Comment: Step 3.
//    - Timer: Show until timer expires, then hide instantly                                // Comment: Step 3a.
//    - TimerWithFade: Show and gradually fade out as timer approaches 0                    // Comment: Step 3b.
//    - ManualDismiss: Show with a "Dismiss" button, ignore timer                           // Comment: Step 3c.
//                                                                                          // Spacer.
void StatusMessage::Render(float deltaTime)                                                 // Method definition.
{
	if (!visible_) {                                                                        // Check visibility.
		return;  // Nothing to show                                                         // Exit if hidden.
	}

	// Countdown the timer (subtract time since last frame)                                 // Comment: Timer logic.
	timer_ -= deltaTime;                                                                    // Decrement timer.

	// Handle different display modes                                                       // Comment: Switch logic.
	switch (mode_) {                                                                        // Switch on mode.
	case DisplayMode::Timer:                                                                // Case: Timer.
		// Simple timer - show message until timer expires, then hide instantly             // Comment: Logic.
		if (timer_ > 0.0f) {                                                                // If time remaining...
			ImGui::TextColored(color_, "%s", text_.c_str());                                // Render text.
		}
		else {                                                                              // If timer expired...
			visible_ = false;  // Timer expired, hide the message                           // Hide message.
		}
		break;                                                                              // Break.

	case DisplayMode::TimerWithFade:                                                        // Case: TimerWithFade.
		// Timer with fade - gradually reduce opacity as timer approaches 0                 // Comment: Logic.
		if (timer_ > 0.0f) {                                                                // If time remaining...
			// Calculate fade: when timer = maxDuration, alpha = 1.0 (fully visible)        // Comment: Math.
			//                 when timer = 0, alpha = 0.0 (fully transparent)              // Comment: Math.
			float fadeAlpha = timer_ / maxDuration_;                                        // Calculate alpha.

			// Create faded color by multiplying the alpha channel                          // Comment: Logic.
			ImVec4 fadedColor = color_;                                                     // Copy base color.
			fadedColor.w *= fadeAlpha;  // w is the alpha channel in ImVec4                 // Apply alpha.

			ImGui::TextColored(fadedColor, "%s", text_.c_str());                            // Render faded text.
		}
		else {                                                                              // If timer expired...
			visible_ = false;  // Fade complete, hide the message                           // Hide message.
		}
		break;                                                                              // Break.

	case DisplayMode::ManualDismiss:                                                        // Case: ManualDismiss.
		// Manual dismiss - show message with a "Dismiss" button                            // Comment: Logic.
		// Timer is ignored in this mode (message stays until user clicks button)           // Comment: Logic.
		ImGui::TextColored(color_, "%s", text_.c_str());                                    // Render text.
		ImGui::SameLine();  // Put the button on the same line as the text                  // Render inline.

		// Show a small dismiss button next to the message                                  // Comment: Logic.
		if (ImGui::SmallButton("Dismiss")) {                                                // Render button and check click.
			visible_ = false;  // User clicked dismiss, hide the message                    // Hide message.
		}
		break;                                                                              // Break.
	}
}

//                                                                                          // Spacer.
// Clear - Immediately hide the message                                                     // Comment: Method implementation.
//                                                                                          // Spacer.
// Use this to force the message to disappear right now, regardless of timer or mode.       // Comment: Details.
// It's like hitting a "cancel" button - resets everything back to empty/hidden state.      // Comment: Analogy.
//                                                                                          // Spacer.
void StatusMessage::Clear()                                                                 // Method definition.
{
	text_.clear();                                                                          // Clear text string.
	color_ = ImVec4(0, 0, 0, 0);  // Transparent black (invisible)                          // Reset color.
	timer_ = 0.0f;                                                                          // Reset timer.
	maxDuration_ = 0.0f;                                                                    // Reset max duration.
	visible_ = false;                                                                       // Set visible to false.
}

//                                                                                          // Spacer.
// IsVisible - Check if a message is currently showing                                      // Comment: Method implementation.
//                                                                                          // Spacer.
// Returns true if there's a message on screen, false if hidden.                            // Comment: Details.
//                                                                                          // Spacer.
bool StatusMessage::IsVisible() const                                                       // Method definition.
{
	return visible_;                                                                        // Return visibility state.
}

//                                                                                          // Spacer.
// GetColorForType - Helper to map message type to color                                    // Comment: Method implementation.
//                                                                                          // Spacer.
// This is a private helper that returns the standard color for each message type.          // Comment: Details.
// Think of it as a "color palette" for the different message categories.                   // Comment: Analogy.
//                                                                                          // Spacer.
// Colors chosen to match common UI conventions:                                            // Comment: Details.
// - Success: Green (like a checkmark or "go" signal)                                       // Comment: Details.
// - Error: Red (like a stop sign or warning light)                                         // Comment: Details.
// - Warning: Yellow/Orange (like caution tape)                                             // Comment: Details.
// - Info: Blue (like information signs)                                                    // Comment: Details.
//                                                                                          // Spacer.
ImVec4 StatusMessage::GetColorForType(Type type) const                                      // Method definition.
{
	switch (type) {                                                                         // Switch on type.
	case Type::Success:                                                                     // Case: Success.
		return ImVec4(0.0f, 1.0f, 0.0f, 1.0f);  // Bright green (R=0, G=1, B=0, A=1)        // Return green.

	case Type::Error:                                                                       // Case: Error.
		return ImVec4(1.0f, 0.0f, 0.0f, 1.0f);  // Bright red (R=1, G=0, B=0, A=1)          // Return red.

	case Type::Warning:                                                                     // Case: Warning.
		return ImVec4(1.0f, 0.8f, 0.0f, 1.0f);  // Yellow/Orange (R=1, G=0.8, B=0, A=1)     // Return yellow.

	case Type::Info:                                                                        // Case: Info.
		return ImVec4(0.4f, 0.7f, 1.0f, 1.0f);  // Light blue (R=0.4, G=0.7, B=1, A=1)      // Return blue.

	default:                                                                                // Default.
		return ImVec4(1.0f, 1.0f, 1.0f, 1.0f);  // White (fallback, should never happen)    // Return white.
	}
}

} // namespace UI                                                                           // End namespace.

// ======================================================================================
// FILE: LoadoutUI.h
// ======================================================================================
#pragma once                                                                                // Ensure header is included once.
#include "IMGUI/imgui.h"                                                                    // Include ImGui library.
#include "StatusMessageUI.h"                                                                // Include StatusMessage class.
#include <string>                                                                           // Include std::string.
#include <vector>                                                                           // Include std::vector.

class SuiteSpot;                                                                            // Forward declaration of SuiteSpot class.

class LoadoutUI {                                                                           // Class definition.
public:                                                                                     // Public interface.
    explicit LoadoutUI(SuiteSpot* plugin);                                                  // Constructor taking plugin pointer.
    void RenderLoadoutControls();                                                           // Main render function for loadout controls.

private:                                                                                    // Private members.
    SuiteSpot* plugin_;                                                                     // Pointer to main plugin instance.

    UI::StatusMessage loadoutStatus;                                                        // Status message object for loadout feedback.
    std::string currentLoadoutName;                                                         // Stores name of currently active loadout.
    std::vector<std::string> loadoutNames;                                                  // Cache of available loadout names.
    int selectedLoadoutIndex = 0;                                                           // Index of currently selected loadout in dropdown.
    bool loadoutsInitialized = false;                                                       // Flag to track if loadouts have been fetched.
};                                                                                          // End of class.


// ====================================================================================== 
// FILE: LoadoutUI.cpp
// ====================================================================================== 
#include "pch.h"                                                                            // Include precompiled header. 

#include "LoadoutUI.h"                                                                      // Include corresponding header. 
#include "SuiteSpot.h"                                                                      // Include main plugin class. 
#include "ConstantsUI.h"                                                                    // Include UI constants. 
#include "HelpersUI.h"                                                                      // Include UI helpers. 

LoadoutUI::LoadoutUI(SuiteSpot* plugin) : plugin_(plugin) {}                                // Constructor: Store plugin pointer. 

void LoadoutUI::RenderLoadoutControls() {                                                   // Method: Renders the loadout manager UI. 
    ImGui::Spacing();                                                                       // Add vertical spacing. 

    auto* loadoutManager = plugin_->loadoutManager.get();                                   // Get pointer to LoadoutManager. 
    if (loadoutManager) {                                                                   // Check if manager exists. 
        if (!loadoutsInitialized) {                                                         // If loadouts not yet initialized... 
            loadoutNames = loadoutManager->GetLoadoutNames();                               // Fetch list of loadout names. 
            loadoutManager->GetCurrentLoadoutName([this](std::string name) {                // Async fetch current loadout name. 
                currentLoadoutName = name;                                                  // Update current name callback. 
            });                                                                             // ... 
            loadoutsInitialized = true;                                                     // Mark as initialized. 
        } 

        ImGui::TextColored(UI::LoadoutUI::SECTION_HEADER_COLOR, "Current Loadout:");        // Display header text with constant color. 
        ImGui::SameLine();                                                                  // Move cursor to same line. 
        if (currentLoadoutName.empty()) {                                                   // If name is unknown... 
            ImGui::TextUnformatted("<Unknown>");                                            // Display placeholder. 
            if (ImGui::IsItemHovered()) {                                                   // Tooltip logic. 
                ImGui::SetTooltip("Loadout not detected yet. Refresh to check available presets."); // Tooltip text. 
            } 
        } else {                                                                            // If name is known... 
            ImGui::TextUnformatted(currentLoadoutName.c_str());                             // Display current loadout name. 
            if (ImGui::IsItemHovered()) {                                                   // Tooltip logic. 
                ImGui::SetTooltip("Your currently equipped loadout preset");                // Tooltip text. 
            } 
        } 

        ImGui::Spacing();                                                                   // Add spacing. 

        if (loadoutNames.empty()) {                                                         // If no loadouts found... 
            ImGui::TextColored(UI::LoadoutUI::ERROR_WARNING_TEXT_COLOR, "No loadouts found. Open Garage to create presets, then click Refresh."); // Show warning. 
        } else {                                                                            // If loadouts exist... 
            const char* comboLabel = (selectedLoadoutIndex >= 0 && selectedLoadoutIndex < (int)loadoutNames.size()) ? // Determine label. 
                loadoutNames[selectedLoadoutIndex].c_str() : "<Select loadout>";            // Use selected name or placeholder. 
            ImGui::SetNextItemWidth(UI::LoadoutUI::LOADOUT_SELECTOR_DROPDOWN_WIDTH);        // Set dropdown width from constant. 
            if (ImGui::BeginCombo("##loadout_combo", comboLabel)) {                         // Start dropdown combo. 
                for (int i = 0; i < (int)loadoutNames.size(); ++i) {                        // Loop through loadouts. 
                    bool isSelected = (i == selectedLoadoutIndex);                          // Check if currently selected. 
                    if (ImGui::Selectable(loadoutNames[i].c_str(), isSelected)) {           // Create selectable item. 
                        selectedLoadoutIndex = i;                                           // Update index on click. 
                    } 
                    if (isSelected) {                                                       // If selected... 
                        ImGui::SetItemDefaultFocus();                                       // Set focus. 
                    } 
                } 
                ImGui::EndCombo();                                                          // End combo. 
            } 
            if (ImGui::IsItemHovered()) {                                                   // Tooltip logic. 
                ImGui::SetTooltip("Select a loadout preset to equip");                      // Tooltip text. 
            } 

            ImGui::SameLine();                                                              // Move to same line. 
            if (ImGui::Button("Apply Loadout")) {                                           // Create Apply button. 
                if (selectedLoadoutIndex >= 0 && selectedLoadoutIndex < (int)loadoutNames.size()) { // Validate selection. 
                    std::string selectedName = loadoutNames[selectedLoadoutIndex];          // Get name. 
                    // Show "Applying..." feedback immediately                              // Comment: User feedback. 
                    loadoutStatus.ShowWarning("Applying...", UI::LoadoutUI::APPLYING_STATUS_DURATION); // Show warning status. 

                    loadoutManager->SwitchLoadout(selectedName, [this, selectedName](bool success) { // Call switch with callback. 
                        if (success) {                                                      // On success... 
                            currentLoadoutName = selectedName;                              // Update current name. 
                            loadoutStatus.ShowSuccess("Applied \"" + selectedName + "\"",   // Show success message. 
                                UI::LoadoutUI::SUCCESS_MESSAGE_DURATION);                   // Duration constant. 
                        } else {                                                            // On failure... 
                            loadoutStatus.ShowError("Failed to apply loadout",              // Show error message. 
                                UI::LoadoutUI::SUCCESS_MESSAGE_DURATION);                   // Duration constant. 
                        } 
                    }); 
                } 
            } 
            if (ImGui::IsItemHovered()) {                                                   // Tooltip logic. 
                ImGui::SetTooltip("Equip the selected loadout preset");                     // Tooltip text. 
            } 
        } 

        ImGui::SameLine();                                                                  // Move to same line. 
        if (ImGui::Button("Refresh Loadouts")) {                                            // Create Refresh button. 
            loadoutsInitialized = false;                                                    // Reset initialized flag. 
            loadoutManager->RefreshLoadoutCache();                                          // Trigger cache refresh. 
            loadoutNames = loadoutManager->GetLoadoutNames();                               // Update list. 
            loadoutManager->GetCurrentLoadoutName([this](std::string name) {                // Async update current name. 
                currentLoadoutName = name;                                                  // ... 
            }); 
            selectedLoadoutIndex = 0;                                                       // Reset selection. 
            loadoutStatus.ShowInfo("Loadouts refreshed", UI::LoadoutUI::REFRESH_MESSAGE_DURATION); // Show status info. 
        } 
        if (ImGui::IsItemHovered()) {                                                       // Tooltip logic. 
            ImGui::SetTooltip("Refresh the list of available loadout presets");             // Tooltip text. 
        } 

        ImGui::Spacing();                                                                   // Add spacing. 
        ImGui::TextDisabled(("Available loadouts: " + std::to_string(loadoutNames.size())).c_str()); // Show count. 

        loadoutStatus.Render(ImGui::GetIO().DeltaTime);                                     // Render status message (every frame). 
    } else {                                                                                // If manager null... 
        ImGui::TextColored(UI::LoadoutUI::ERROR_WARNING_TEXT_COLOR, "LoadoutManager not initialized"); // Show error. 
    } 
}

// ======================================================================================
// FILE: SettingsUI.h
// ======================================================================================
#pragma once                                                                                // Ensure header is included only once.
#include "IMGUI/imgui.h"                                                                    // Include ImGui library.
#include "StatusMessageUI.h"                                                                // Include StatusMessage class.
#include <string>                                                                           // Include string support.
#include <vector>                                                                           // Include vector support.

/*                                                                                          // Spacer.
 * ======================================================================================   // Comment: Header.
 * SETTINGS UI: THE CONFIGURATION MENU                                                      // Comment: Title.
 * ======================================================================================   // Comment: Header.
 *                                                                                          // Spacer.
 * WHAT IS THIS?                                                                            // Comment: Section.
 * This class builds the visual menu you see when you press F2 in Rocket League and         // Comment: Description.
 * click on the "SuiteSpot" tab.                                                            // Comment: Description.
 *                                                                                          // Spacer.
 * WHY IS IT HERE?                                                                          // Comment: Section.
 * Users need a way to change settings (like delay times or which map to load).             // Comment: Description.
 * This class translates those settings into buttons, sliders, and checkboxes.              // Comment: Description.
 *                                                                                          // Spacer.
 * HOW DOES IT WORK?                                                                        // Comment: Section.
 * 1. `RenderMainSettingsWindow()`: This is the main loop. It draws the tabs ("Main Settings", // Comment: Step 1.
 *    "Auto-Queue", etc.).                                                                  // Comment: Step 1.
 * 2. It reads the current values from `SuiteSpot` (which gets them from `SettingsSync`).   // Comment: Step 2.
 * 3. When you change a value (like sliding a slider), it immediately tells `SettingsSync`  // Comment: Step 3.
 *    to save that new value to the config file.                                            // Comment: Step 3.
 * 4. It uses `UI::Helpers` to make the code cleaner (so we don't have to write             // Comment: Step 4.
 *    "Draw Slider" logic 50 times).                                                        // Comment: Step 4.
 */                                                                                         // Spacer.

class SuiteSpot;                                                                            // Forward declaration.

class SettingsUI {                                                                          // Class definition.
public:                                                                                     // Public interface.
    explicit SettingsUI(SuiteSpot* plugin);                                                 // Constructor.
    void RenderMainSettingsWindow();                                                        // Main render method.

private:                                                                                    // Private members.
    SuiteSpot* plugin_;                                                                     // Pointer to main plugin.
    UI::StatusMessage statusMessage; // Shows "Success!" or error messages                  // Status message helper.

    // Internal helpers to draw specific tabs                                               // Comment: Helper methods.
    // These break the big menu into smaller, manageable chunks                             // Comment: Purpose.
    void RenderGeneralTab(bool& enabledValue, int& mapTypeValue);                           // Render General tab.
    void RenderMapSelectionTab(int mapTypeValue, bool bagRotationEnabledValue, std::string& currentFreeplayCode, std::string& currentTrainingCode, std::string& currentWorkshopPath, int& delayFreeplaySecValue, int& delayTrainingSecValue, int& delayWorkshopSecValue, int& delayQueueSecValue); // Render Map Select tab.
    void RenderFreeplayMode(std::string& currentFreeplayCode);                              // Render Freeplay options.
    void RenderTrainingMode(int trainingModeValue, std::string& currentTrainingCode);       // Render Training options.
    void RenderWorkshopMode(std::string& currentWorkshopPath);                              // Render Workshop options.

    void RenderSinglePackMode(std::string& currentTrainingCode);                            // Render Single Pack mode.
    void RenderBagRotationMode();                                                           // Render Bag Rotation mode.
    void RenderLoadNowButton();                                                             // Render Load Now button.
    std::vector<std::string> GetQuickPicksList();                                           // Helper to get Quick Picks.

    // Workshop path configuration state                                                    // Comment: State variables.
    char workshopPathBuf[512] = {0};                                                        // Buffer for workshop path input.
    bool workshopPathInit = false;                                                          // Initialization flag.
    std::string workshopPathCache = "";                                                     // Cache for workshop path.
};                                                                                          // End class.


// ======================================================================================
// FILE: SettingsUI.cpp
// ======================================================================================
#include "pch.h"                                                                            // Precompiled header.

#include "SettingsUI.h"                                                                     // SettingsUI header.
#include "LoadoutUI.h"                                                                      // LoadoutUI header.
#include "TrainingPackUI.h"                                                                 // TrainingPackUI header.
#include "SuiteSpot.h"                                                                      // SuiteSpot main header.
#include "MapManager.h"                                                                     // MapManager header.
#include "TrainingPackManager.h"                                                            // TrainingPackManager header.
#include "SettingsSync.h"                                                                   // SettingsSync header.
#include "ConstantsUI.h"                                                                    // ConstantsUI header.
#include "HelpersUI.h"                                                                      // HelpersUI header.
#include "DefaultPacks.h"                                                                   // DefaultPacks header.

#include <algorithm>                                                                        // Algorithm header.
#include <fstream>                                                                          // File stream header.
#include <sstream>                                                                          // String stream header.
#include <cstring>                                                                          // String manipulation header.

SettingsUI::SettingsUI(SuiteSpot* plugin) : plugin_(plugin) {}                              // Constructor implementation.

void SettingsUI::RenderMainSettingsWindow() {                                               // Main render method.
    if (!plugin_) {                                                                         // Check for null plugin.
        return;                                                                             // Exit if null.
    }

    ImGui::SetWindowFontScale(UI::FONT_SCALE);                                              // Apply font scaling.

    // Header with metadata and Load Now button                                             // Comment: Header section.
    ImGui::BeginGroup();                                                                    // Begin grouping widgets.
    ImGui::TextColored(UI::SettingsUI::HEADER_TEXT_COLOR, "By: Flicks Creations");          // Display author.
    std::string ver = "Version: " + std::string(plugin_version);                            // Format version string.
    ImGui::TextColored(UI::SettingsUI::HEADER_TEXT_COLOR, "%s", ver.c_str());               // Display version.
    ImGui::EndGroup();                                                                      // End grouping.

    ImGui::SameLine(ImGui::GetWindowWidth() - 150.0f);                                      // Align to right.
    if (ImGui::Button("LOAD NOW", ImVec2(130, 26))) {                                       // Draw Load Now button.
        RenderLoadNowButton();                                                              // Call handler.
    }

    ImGui::Spacing();                                                                       // Add spacing.
    statusMessage.Render(ImGui::GetIO().DeltaTime);                                         // Render status message.
    if (statusMessage.IsVisible()) ImGui::Spacing();                                        // Add spacing if visible.

    bool enabledValue = plugin_->IsEnabled();                                               // Get enabled state.
    int mapTypeValue = plugin_->GetMapType();                                               // Get map type.
    bool autoQueueValue = plugin_->IsAutoQueueEnabled();                                    // Get auto-queue state.
    bool bagRotationEnabledValue = plugin_->IsBagRotationEnabled();                         // Get bag rotation state.
    int trainingModeValue = plugin_->settingsSync->GetTrainingMode();                       // Get training mode.
    int delayQueueSecValue = plugin_->GetDelayQueueSec();                                   // Get queue delay.
    int delayFreeplaySecValue = plugin_->GetDelayFreeplaySec();                             // Get freeplay delay.
    int delayTrainingSecValue = plugin_->GetDelayTrainingSec();                             // Get training delay.
    int delayWorkshopSecValue = plugin_->GetDelayWorkshopSec();                             // Get workshop delay.
    std::string currentFreeplayCode = plugin_->GetCurrentFreeplayCode();                    // Get freeplay code.
    std::string currentTrainingCode = plugin_->GetCurrentTrainingCode();                    // Get training code.
    std::string quickPicksSelectedCode = plugin_->settingsSync->GetQuickPicksSelectedCode(); // Get quick pick code.
    std::string currentWorkshopPath = plugin_->GetCurrentWorkshopPath();                    // Get workshop path.

    // Only show status if enabled                                                          // Comment: Status display logic.
    if (enabledValue) {                                                                     // Check if enabled.
        ImGui::Separator();                                                                 // Draw separator.

        const char* modeNames[] = {"Freeplay", "Training", "Workshop"};                     // Mode names array.
        std::string currentMap = "<none>";                                                  // Default map text.
        std::string queueDelayStr = std::to_string(delayQueueSecValue) + "s";               // Format queue delay.
        std::string mapDelayStr = "0s";                                                     // Default map delay.
        const ImVec4 white = UI::SettingsUI::STATUS_SEPARATOR_COLOR;                        // Separator color.

        // Get current selection and appropriate delay                                      // Comment: Logic.
        if (mapTypeValue == 0) {                                                            // Freeplay mode.
            // Find freeplay map by code                                                    // Comment: Lookup.
            auto it = std::find_if(RLMaps.begin(), RLMaps.end(),                            // Find map.
                [&](const MapEntry& e) { return e.code == currentFreeplayCode; });          // Lambda predicate.
            if (it != RLMaps.end()) {                                                       // If found...
                currentMap = it->name;                                                      // Use name.
            }
            mapDelayStr = std::to_string(delayFreeplaySecValue) + "s";                      // Set delay string.
        } else if (mapTypeValue == 1) {                                                     // Training mode.
            mapDelayStr = std::to_string(delayTrainingSecValue) + "s";                      // Set delay string.

            // Get packs from manager for consistent lookup                                 // Comment: Manager access.
            const auto& trainingPacks = plugin_->trainingPackMgr ?                          // Check manager.
                plugin_->trainingPackMgr->GetPacks() : RLTraining;                          // Use manager or default.

            if (trainingModeValue == 1 && plugin_->trainingPackMgr) {                       // Bag rotation mode.
                // Show current bag in rotation                                             // Comment: Bag logic.
                auto [pack, bagName] = plugin_->PeekNextBagPack();                          // Peek next pack.
                if (!pack.code.empty()) {                                                   // If pack valid...
                    currentMap = "Next: " + pack.name + " (from " + bagName + ")";          // Format string.
                } else {                                                                    // If empty...
                    currentMap = "Bag Rotation: <empty>";                                   // Format string.
                }
            } else {                                                                        // Single pack mode.
                // Single Pack Mode                                                         // Comment.
                std::string targetCode = quickPicksSelectedCode;                            // Use quick pick.
                if (targetCode.empty()) targetCode = currentTrainingCode;                   // Fallback.

                if (!targetCode.empty()) {                                                  // If code exists...
                    auto it = std::find_if(trainingPacks.begin(), trainingPacks.end(),      // Find pack.
                        [&](const TrainingEntry& e) { return e.code == targetCode; });      // Lambda.
                    if (it != trainingPacks.end()) {                                        // If found...
                        currentMap = it->name + " (Shots:" + std::to_string(it->shotCount) + ")"; // Format name.
                    } else {                                                                // If not found...
                        currentMap = targetCode;                                            // Use raw code.
                    }
                }
            }
        } else if (mapTypeValue == 2) {                                                     // Workshop mode.
            // Find workshop map by path                                                    // Comment: Lookup.
            auto it = std::find_if(RLWorkshop.begin(), RLWorkshop.end(),                    // Find map.
                [&](const WorkshopEntry& e) { return e.filePath == currentWorkshopPath; }); // Lambda.
            if (it != RLWorkshop.end()) {                                                   // If found...
                currentMap = it->name;                                                      // Use name.
            }
            mapDelayStr = std::to_string(delayWorkshopSecValue) + "s";                      // Set delay string.
        }

        // Map mode status                                                                  // Comment: Display logic.
        const ImVec4 green = UI::SettingsUI::STATUS_ENABLED_TEXT_COLOR;                     // Green color.
        const ImVec4 red   = UI::SettingsUI::STATUS_DISABLED_TEXT_COLOR;                    // Red color.
        std::string modeText = "Mode: " + std::string(modeNames[mapTypeValue]);             // Format mode text.
        
        int currentDelay = (mapTypeValue == 0) ? delayFreeplaySecValue : (mapTypeValue == 1 ? delayTrainingSecValue : delayWorkshopSecValue); // Calc delay.
        if (currentDelay > 0) {                                                             // If delayed...
            modeText += " Delayed: " + mapDelayStr;                                         // Append delay info.
        }

        ImGui::TextColored(green, "%s", modeText.c_str());                                  // Draw mode text.
        ImGui::SameLine();                                                                  // Inline.
        ImGui::TextColored(white, "|");                                                     // Draw separator.
        ImGui::SameLine();                                                                  // Inline.
        ImGui::TextColored(green, "Map: %s", currentMap.c_str());                           // Draw map name.
        ImGui::SameLine();                                                                  // Inline.
        ImGui::TextColored(white, "|");                                                     // Draw separator.
        ImGui::SameLine();                                                                  // Inline.
        const ImVec4 queueColor = autoQueueValue ? green : red;                             // Determine queue color.
        if (delayQueueSecValue > 0) {                                                       // If queue delayed...
            ImGui::TextColored(queueColor, "Next Match Queue Delayed: %s", queueDelayStr.c_str()); // Draw queue text.
        } else {                                                                            // If no delay...
            ImGui::TextColored(queueColor, "Next Match Queue");                             // Draw queue text.
        }
    }
    
    ImGui::Spacing();                                                                       // Spacing.
    ImGui::Separator();                                                                     // Separator.
    ImGui::Spacing();                                                                       // Spacing.

    // 1) Global Controls                                                                   // Comment: Section.
    // ...                                                                                  // Spacer.
    ImGui::Spacing();                                                                       // Spacing.

    // 1) Global Controls (Enable/Disable + Map Mode) - above the tabs                      // Comment: Section.
    RenderGeneralTab(enabledValue, mapTypeValue);                                           // Render general controls.
    ImGui::Spacing();                                                                       // Spacing.
    ImGui::Separator();                                                                     // Separator.

    // Main tab bar                                                                         // Comment: Tab Bar.
    if (ImGui::BeginTabBar("SuiteSpotTabs", ImGuiTabBarFlags_None)) {                       // Begin Tab Bar.

        // ===== MAP SELECT TAB =====                                                       // Comment: Tab 1.
        if (ImGui::BeginTabItem("Map Select")) {                                            // Begin Tab Item.
            ImGui::Spacing();                                                               // Spacing.

            // 1) Unified Header: Auto-Queue Toggle | Queue Delay | Map Delay               // Comment: Header layout.
            ImGui::Columns(2, "MapSelectHeaderCols", false);                                // Begin columns.
            ImGui::SetColumnWidth(0, 150.0f);                                               // Set width.
            
            // Auto-Queue                                                                   // Comment: Widget.
            UI::Helpers::CheckboxWithCVar("Auto-Queue", autoQueueValue, "suitespot_auto_queue", // Checkbox.
                plugin_->cvarManager, plugin_->gameWrapper, "Automatically queue into the next match after the current match ends."); // Tooltip.
            ImGui::NextColumn();                                                            // Next column.
            ImGui::NextColumn(); // Skip right column                                       // Skip.

            // Queue Delay                                                                  // Comment: Widget.
            ImGui::Text("Queue Delay");                                                     // Label.
            ImGui::NextColumn();                                                            // Next column.
            ImGui::SetNextItemWidth(-1);                                                    // Full width.
            UI::Helpers::InputIntWithRange("##QueueDelay", delayQueueSecValue,              // InputInt.
                UI::SettingsUI::DELAY_QUEUE_MIN_SECONDS, UI::SettingsUI::DELAY_QUEUE_MAX_SECONDS, // Range.
                0.0f, "suitespot_delay_queue_sec", plugin_->cvarManager,
                plugin_->gameWrapper, "Wait before auto-queuing.", nullptr);                // Tooltip.
            ImGui::NextColumn();                                                            // Next column.

            // Map Delay (Context-sensitive)                                                // Comment: Logic.
            int* currentMapDelayValue = &delayFreeplaySecValue;                             // Default ptr.
            const char* currentMapDelayCVar = "suitespot_delay_freeplay_sec";               // Default CVar.
            const char* mapDelayTooltip = "Wait before loading Freeplay.";                  // Default Tooltip.

            if (mapTypeValue == 1) { // Training                                            // Case: Training.
                currentMapDelayValue = &delayTrainingSecValue;                              // Set ptr.
                currentMapDelayCVar = "suitespot_delay_training_sec";                       // Set CVar.
                mapDelayTooltip = "Wait before loading Training.";                          // Set Tooltip.
            } else if (mapTypeValue == 2) { // Workshop                                     // Case: Workshop.
                currentMapDelayValue = &delayWorkshopSecValue;                              // Set ptr.
                currentMapDelayCVar = "suitespot_delay_workshop_sec";                       // Set CVar.
                mapDelayTooltip = "Wait before loading Workshop.";                          // Set Tooltip.
            }

            ImGui::Text("Map Delay");                                                       // Label.
            ImGui::NextColumn();                                                            // Next column.
            ImGui::SetNextItemWidth(-1);                                                    // Full width.
            UI::Helpers::InputIntWithRange("##MapDelay", *currentMapDelayValue,             // InputInt.
                0, 300, 0.0f, currentMapDelayCVar, plugin_->cvarManager,
                plugin_->gameWrapper, mapDelayTooltip, nullptr);                            // Tooltip.
            ImGui::NextColumn();                                                            // Next column.

            ImGui::Columns(1); // Reset                                                     // Reset columns.
            
            ImGui::Spacing();                                                               // Spacing.
            ImGui::Separator();                                                             // Separator.
            ImGui::Spacing();                                                               // Spacing.

            // 2) Map Selection Logic                                                       // Comment: Logic.
            RenderMapSelectionTab(mapTypeValue, (trainingModeValue == 1), currentFreeplayCode, // Call map selection render.
                currentTrainingCode, currentWorkshopPath, delayFreeplaySecValue,
                delayTrainingSecValue, delayWorkshopSecValue, delayQueueSecValue);          // Params.

            ImGui::EndTabItem();                                                            // End Tab.
        }

        // ===== LOADOUT MANAGEMENT TAB =====                                               // Comment: Tab 2.
        if (ImGui::BeginTabItem("Loadout Management")) {                                    // Begin Tab Item.
            if (plugin_->loadoutUI) {                                                       // Check UI instance.
                plugin_->loadoutUI->RenderLoadoutControls();                                // Render loadout UI.
            }
            ImGui::EndTabItem();                                                            // End Tab.
        }

        ImGui::EndTabBar();                                                                 // End Tab Bar.
    }
}

void SettingsUI::RenderGeneralTab(bool& enabledValue, int& mapTypeValue) {                  // RenderGeneralTab implementation.
    ImGui::Columns(2, "GeneralTabCols", false); // Invisible columns                        // Begin columns.
    
    // Col 1: Enable                                                                        // Comment: Col 1.
    UI::Helpers::CheckboxWithCVar("Enable SuiteSpot", enabledValue, "suitespot_enabled",    // Checkbox.
        plugin_->cvarManager, plugin_->gameWrapper, "Enable/disable all SuiteSpot auto-loading and queuing features"); // Tooltip.
    
    ImGui::NextColumn();                                                                    // Next column.
    
    // Col 2: Map Mode                                                                      // Comment: Col 2.
    ImGui::TextUnformatted("Map Mode:");                                                    // Label.
    ImGui::SameLine();                                                                      // Inline.
    
    const char* mapLabels[] = {"Freeplay", "Training", "Workshop"};                         // Map labels.
    for (int i = 0; i < 3; i++) {                                                           // Loop types.
        if (i > 0) ImGui::SameLine(0, UI::SettingsUI::MAP_TYPE_RADIO_BUTTON_SPACING);       // Spacing.
        if (ImGui::RadioButton(mapLabels[i], mapTypeValue == i)) {                          // Radio button.
            mapTypeValue = i;                                                               // Set type.
            UI::Helpers::SetCVarSafely("suitespot_map_type", mapTypeValue, plugin_->cvarManager, plugin_->gameWrapper); // Save CVar.
        }
    }
    if (ImGui::IsItemHovered()) {                                                           // Tooltip.
        ImGui::SetTooltip("Choose which map type loads after matches:\nFreeplay = Official | Training = Custom Packs | Workshop = Modded Maps"); // Text.
    }
    
    ImGui::Columns(1); // Reset                                                             // Reset columns.
}
void SettingsUI::RenderMapSelectionTab(int mapTypeValue,                                    // RenderMapSelectionTab implementation.
    bool unused, // retired                                                                 // Unused param.
    std::string& currentFreeplayCode,                                                       // Freeplay code ref.
    std::string& currentTrainingCode,                                                       // Training code ref.
    std::string& currentWorkshopPath,                                                       // Workshop path ref.
    int& delayFreeplaySecValue,                                                             // Freeplay delay ref.
    int& delayTrainingSecValue,                                                             // Training delay ref.
    int& delayWorkshopSecValue,                                                             // Workshop delay ref.
    int& delayQueueSecValue) {                                                              // Queue delay ref.
    ImGui::TextUnformatted("Map Selection:");                                               // Header text.
    ImGui::Spacing();                                                                       // Spacing.

    if (mapTypeValue == 0) {                                                                // If Freeplay...
        RenderFreeplayMode(currentFreeplayCode);                                            // Render freeplay.
    } else if (mapTypeValue == 1) {                                                         // If Training...
        int trainingModeValue = plugin_->settingsSync->GetTrainingMode();                   // Get training mode.
        RenderTrainingMode(trainingModeValue, currentTrainingCode);                         // Render training.
    } else if (mapTypeValue == 2) {                                                         // If Workshop...
        RenderWorkshopMode(currentWorkshopPath);                                            // Render workshop.
    }
}

void SettingsUI::RenderFreeplayMode(std::string& currentFreeplayCode) {                     // RenderFreeplayMode implementation.
    // Find current selection index for display                                             // Comment: Index search.
    int currentIndex = 0;                                                                   // Default index.
    if (!currentFreeplayCode.empty()) {                                                     // If code not empty...
        for (int i = 0; i < (int)RLMaps.size(); i++) {                                      // Loop maps.
            if (RLMaps[i].code == currentFreeplayCode) {                                    // Match code.
                currentIndex = i;                                                           // Set index.
                break;                                                                      // Break.
            }
        }
    }

    const char* freeplayLabel = RLMaps.empty() ? "<none>" : RLMaps[currentIndex].name.c_str(); // Get label.
    
    ImGui::Columns(2, "FreeplayCols", false);                                               // Begin columns.
    ImGui::SetColumnWidth(0, 150.0f);                                                       // Set width.
    
    ImGui::Text("Freeplay Map");                                                            // Label.
    ImGui::NextColumn();                                                                    // Next column.
    
    ImGui::SetNextItemWidth(-1);                                                            // Full width.
    if (UI::Helpers::ComboWithTooltip("##FreeplayMap", freeplayLabel,
        "Select which stadium to load after matches", -1.0f)) {                             // Tooltip.
        ImGuiListClipper clipper;
        clipper.Begin((int)RLMaps.size());                                                  // Begin clipper.
        while (clipper.Step()) {                                                            // Step clipper.
            for (int row = clipper.DisplayStart; row < clipper.DisplayEnd; row++) {         // Loop visible rows.
                bool selected = (RLMaps[row].code == currentFreeplayCode);                  // Check selected.
                if (ImGui::Selectable(RLMaps[row].name.c_str(), selected)) {                // Selectable item.
                    currentFreeplayCode = RLMaps[row].code;                                 // Update code.
                    plugin_->settingsSync->SetCurrentFreeplayCode(currentFreeplayCode);     // Sync setting.
                    plugin_->cvarManager->getCvar("suitespot_current_freeplay_code").setValue(currentFreeplayCode); // Update CVar.
                }
            }
        }
        ImGui::EndCombo();                                                                  // End combo.
    }
    ImGui::Columns(1);                                                                      // Reset columns.
}

void SettingsUI::RenderTrainingMode(int trainingModeValue, std::string& currentTrainingCode) { // RenderTrainingMode implementation.
    ImGui::TextUnformatted("Training Mode:");                                               // Label.
    ImGui::SameLine();                                                                      // Inline.
    
    if (ImGui::RadioButton("Single Pack", trainingModeValue == 0)) {                        // Radio 1.
        UI::Helpers::SetCVarSafely("suitespot_training_mode", 0, plugin_->cvarManager, plugin_->gameWrapper); // Save 0.
    }
    ImGui::SameLine();                                                                      // Inline.
    if (ImGui::RadioButton("Bag Rotation", trainingModeValue == 1)) {                       // Radio 2.
        UI::Helpers::SetCVarSafely("suitespot_training_mode", 1, plugin_->cvarManager, plugin_->gameWrapper); // Save 1.
    }

    ImGui::Separator();                                                                     // Separator.
    ImGui::Spacing();                                                                       // Spacing.

    if (trainingModeValue == 0) {                                                           // If Single Pack...
        RenderSinglePackMode(currentTrainingCode);                                          // Render single pack UI.
    } else {                                                                                // If Bag Rotation...
        RenderBagRotationMode();                                                            // Render bag UI.
    }

    ImGui::Spacing();                                                                       // Spacing.
    ImGui::Separator();                                                                     // Separator.
    ImGui::Spacing();                                                                       // Spacing.

    if (ImGui::Button("Open Training Pack Browser", ImVec2(250, 30))) {                     // Browser button.
        SuiteSpot* p = plugin_;                                                             // Alias.
        p->gameWrapper->SetTimeout([p](GameWrapper* gw) {                                   // Timeout.
            p->cvarManager->executeCommand("togglemenu suitespot_browser");                 // Execute toggle command.
        }, 0.0f);                                                                           // Immediate.
    }
    if (ImGui::IsItemHovered()) {                                                           // Tooltip.
        ImGui::SetTooltip("Open the full training pack browser to manage bags and packs");    // Text.
    }
}

void SettingsUI::RenderWorkshopMode(std::string& currentWorkshopPath) {                     // RenderWorkshopMode implementation.
    // Find current selection index for display                                             // Comment: Index search.
    int currentIndex = 0;                                                                   // Default.
    if (!currentWorkshopPath.empty()) {                                                     // If path valid...
        for (int i = 0; i < (int)RLWorkshop.size(); i++) {                                  // Loop maps.
            if (RLWorkshop[i].filePath == currentWorkshopPath) {                            // Match path.
                currentIndex = i;                                                           // Set index.
                break;                                                                      // Break.
            }
        }
    }

    const char* workshopLabel = RLWorkshop.empty() ? "<none>" : RLWorkshop[currentIndex].name.c_str(); // Label.
    
    ImGui::Columns(2, "WorkshopCols", false);                                               // Columns.
    ImGui::SetColumnWidth(0, 150.0f);                                                       // Width.

    ImGui::Text("Workshop Map");                                                            // Label.
    ImGui::NextColumn();                                                                    // Next.

    ImGui::SetNextItemWidth(-1);                                                            // Full width.
    if (UI::Helpers::ComboWithTooltip("##WorkshopMap", workshopLabel,
        "Select which workshop map to load after matches", -1.0f)) {                        // Tooltip.
        ImGuiListClipper clipper;
        clipper.Begin((int)RLWorkshop.size());                                              // Begin.
        while (clipper.Step()) {                                                            // Step.
            for (int row = clipper.DisplayStart; row < clipper.DisplayEnd; row++) {         // Loop.
                bool selected = (RLWorkshop[row].filePath == currentWorkshopPath);          // Check selected.
                std::string label = RLWorkshop[row].name + "##" + std::to_string(row);      // Unique label.
                if (ImGui::Selectable(label.c_str(), selected)) {                           // Selectable.
                    currentWorkshopPath = RLWorkshop[row].filePath;                         // Update path.
                    plugin_->settingsSync->SetCurrentWorkshopPath(currentWorkshopPath);     // Sync.
                    plugin_->cvarManager->getCvar("suitespot_current_workshop_path").setValue(currentWorkshopPath); // Update CVar.
                }
            }
        }
        ImGui::EndCombo();                                                                  // End.
    }

    if (ImGui::Button("Refresh List", ImVec2(-1, 0))) {                                     // Refresh button.
        // After refresh, selection persists automatically since we use path-based lookup   // Comment.
        plugin_->LoadWorkshopMaps();                                                        // Reload maps.
    }
    ImGui::Columns(1);                                                                      // Reset.

    ImGui::Spacing();                                                                       // Spacing.
    if (ImGui::TreeNodeEx("Workshop Source", ImGuiTreeNodeFlags_DefaultOpen)) {             // Tree Node.
        if (!workshopPathInit) {                                                            // If not init...
            auto resolved = plugin_->ResolveConfiguredWorkshopRoot();                       // Resolve path.
            if (resolved.empty()) {                                                         // If empty...
                const char* pfx86 = std::getenv("ProgramFiles(x86)");                       // Try env var.
                if (pfx86) {                                                                // If exists...
                    workshopPathCache = (std::filesystem::path(pfx86) / "Steam" / "steamapps" / "common" / "rocketleague" / "TAGame" / "CookedPCConsole" / "mods").string(); // Default path.
                } else {                                                                    // Else...
                    workshopPathCache = "";                                                 // Empty.
                }
            } else {                                                                        // If resolved...
                workshopPathCache = resolved.string();                                      // Use it.
            }
            strncpy_s(workshopPathBuf, workshopPathCache.c_str(), sizeof(workshopPathBuf) - 1); // Copy to buffer.
            workshopPathInit = true;                                                        // Set init.
        }

        ImGui::Columns(2, "WorkshopSourceCols", false);                                     // Columns.
        ImGui::SetColumnWidth(0, 150.0f);                                                   // Width.

        ImGui::Text("Maps Root Folder");                                                    // Label.
        ImGui::NextColumn();                                                                // Next.

        ImGui::SetNextItemWidth(-1.0f);                                                     // Full width.
        ImGui::InputText("##workshop_root", workshopPathBuf, IM_ARRAYSIZE(workshopPathBuf)); // Input text.

        if (ImGui::Button("Save Path", ImVec2(-1, 0))) {                                    // Save button.
            std::filesystem::path workshopPath(workshopPathBuf);                            // Create path object.
            if (!workshopPath.empty() && std::filesystem::exists(workshopPath) && std::filesystem::is_directory(workshopPath)) { // Validate.
                std::filesystem::path cfgPath = plugin_->GetWorkshopLoaderConfigPath();     // Get config path.
                std::filesystem::create_directories(cfgPath.parent_path());                 // Create dirs.
                std::ofstream cfg(cfgPath.string(), std::ios::trunc);                       // Open file.
                if (cfg.is_open()) {                                                        // If open...
                    cfg << "MapsFolderPath=" << workshopPathBuf << "\n";                    // Write config.
                    cfg.close();                                                            // Close.
                    workshopPathCache = workshopPathBuf;                                    // Update cache.
                    plugin_->LoadWorkshopMaps();                                            // Reload maps.
                    statusMessage.ShowSuccess("Workshop path saved!", 3.0f, UI::StatusMessage::DisplayMode::TimerWithFade); // Success message.
                }
            }
        }
        ImGui::Columns(1);                                                                      // Reset.
        ImGui::TreePop();                                                                   // Pop tree.
    }
}

void SettingsUI::RenderSinglePackMode(std::string& currentTrainingCode) {                   // RenderSinglePackMode implementation.
    ImGui::TextColored(UI::TrainingPackUI::SECTION_HEADER_TEXT_COLOR, "Quick Picks (Favorites)"); // Header.
    ImGui::SameLine();                                                                      // Inline.
    ImGui::TextDisabled("(Select post-match pack)");                                        // Subtext.

    std::vector<std::string> quickPicks = GetQuickPicksList();                              // Get list.
    std::string selectedCode = plugin_->settingsSync->GetQuickPicksSelectedCode();          // Get selected.
    
    // If nothing selected, default to the first one in the list                            // Comment: Default logic.
    if (selectedCode.empty() && !quickPicks.empty()) {                                      // If empty selection...
        selectedCode = quickPicks[0];                                                       // Pick first.
        plugin_->settingsSync->SetQuickPicksSelected(selectedCode);                         // Set sync.
        plugin_->cvarManager->getCvar("suitespot_quickpicks_selected").setValue(selectedCode); // Set CVar.
    }

    if (ImGui::BeginChild("QuickPicksList", ImVec2(0, UI::QuickPicksUI::TABLE_HEIGHT), true)) { // Begin scrollable list.
        for (const auto& code : quickPicks) {                                               // Loop codes.
            std::string name = "Unknown Pack";                                              // Default name.
            int shots = 0;                                                                  // Default shots.
            std::string description = "";                                                   // Default desc.
            bool found = false;                                                             // Found flag.

            // 1. Try to find in loaded cache                                               // Comment: Cache lookup.
            const auto& trainingPacks = plugin_->trainingPackMgr ? plugin_->trainingPackMgr->GetPacks() : RLTraining; // Get packs.
            auto it = std::find_if(trainingPacks.begin(), trainingPacks.end(), [&](const TrainingEntry& e) { return e.code == code; }); // Find. 
            
            if (it != trainingPacks.end()) {                                                // If found...
                name = it->name;                                                            // Set name.
                shots = it->shotCount;                                                      // Set shots.
                description = it->staffComments.empty() ? it->notes : it->staffComments;    // Set desc.
                found = true;                                                               // Set flag.
            } else {                                                                        // If not found...
                // 2. Try to find in DefaultPacks (Hardcoded fallback for first run)        // Comment: Fallback lookup.
                for (const auto& defPack : DefaultPacks::FLICKS_PICKS) {                    // Loop defaults.
                    if (defPack.code == code) {                                             // Match code.
                        name = defPack.name;                                                // Set name.
                        shots = defPack.shotCount;                                          // Set shots.
                        description = defPack.description;                                  // Set desc.
                        found = true;                                                       // Set flag.
                        break;                                                              // Break.
                    }
                }
            }

            if (found) {                                                                    // If found...
                bool isSelected = (code == selectedCode);                                   // Check selected.
                ImGui::PushID(code.c_str());                                                // Push ID.
                if (ImGui::RadioButton("##select", isSelected)) {                           // Radio button.
                    selectedCode = code;                                                    // Update selected.
                    plugin_->settingsSync->SetQuickPicksSelected(code);                     // Sync.
                    plugin_->cvarManager->getCvar("suitespot_quickpicks_selected").setValue(code); // CVar.
                }
                ImGui::SameLine();                                                          // Inline.
                
                // Name and Shot Count                                                      // Comment: Display.
                float availWidth = ImGui::GetContentRegionAvail().x;                        // Calc width.
                ImGui::Text("%s", name.c_str());                                            // Draw name.
                ImGui::SameLine(availWidth - 80.0f);                                        // Align right.
                ImGui::TextDisabled("| %d shots", shots);                                   // Draw shots.

                // Description (Indented and Wrapped)                                       // Comment: Description.
                if (!description.empty()) {                                                 // If desc exists...
                    ImGui::Indent(28.0f);                                                   // Indent.
                    ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(0.7f, 0.7f, 0.7f, 1.0f));   // Gray color.
                    ImGui::PushTextWrapPos(ImGui::GetWindowContentRegionWidth() - 10.0f);   // Wrap.
                    ImGui::TextUnformatted(description.c_str());                            // Draw desc.
                    ImGui::PopTextWrapPos();                                                // Pop wrap.
                    ImGui::PopStyleColor();                                                 // Pop color.
                    ImGui::Unindent(28.0f);                                                 // Unindent.
                }
                
                ImGui::Separator();                                                         // Separator.
                ImGui::PopID();                                                             // Pop ID.
            }
        }
    }
    ImGui::EndChild();                                                                      // End child.
}

void SettingsUI::RenderBagRotationMode() {                                                  // RenderBagRotationMode implementation.
    if (!plugin_->trainingPackMgr) {                                                        // Check manager.
        ImGui::TextDisabled("Training Pack Manager not available");                         // Error text.
        return;                                                                             // Exit.
    }

    auto [pack, bagName] = plugin_->PeekNextBagPack();                                      // Peek next pack.
    
    ImGui::Text("Current Bag: ");                                                           // Label.
    ImGui::SameLine();                                                                      // Inline.
    ImGui::TextColored(ImVec4(0.4f, 0.8f, 1.0f, 1.0f), "%s", bagName.empty() ? "<none>" : bagName.c_str()); // Display bag name.

    ImGui::Text("Next Pack: ");                                                             // Label.
    ImGui::SameLine();                                                                      // Inline.
    if (!pack.code.empty()) {                                                               // If pack exists...
        ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f), "%s (%d shots)", pack.name.c_str(), pack.shotCount); // Display pack info.
    } else {                                                                                // If none...
        ImGui::TextDisabled("<none available>");                                            // Display placeholder.
    }

    ImGui::Spacing();                                                                       // Spacing.                                                                               
    if (ImGui::Button(" < Previous ")) {                                                    // Prev button.
        plugin_->RetreatToPreviousBagPack();                                                // Call retreat.
    }
    ImGui::SameLine();                                                                      // Inline.
    if (ImGui::Button(" Next > ")) {                                                        // Next button.
        plugin_->AdvanceToNextBagPack();                                                    // Call advance.
    }
}

void SettingsUI::RenderLoadNowButton() {                                                    // RenderLoadNowButton implementation.
    if (ImGui::Button("  LOAD NOW  ", ImVec2(120, 35))) {                                   // Big button.
        int mapType = plugin_->GetMapType();                                                // Get type.
        SuiteSpot* p = plugin_;                                                             // Alias.

        if (mapType == 0) { // Freeplay                                                     // Case: Freeplay.
            std::string code = p->GetCurrentFreeplayCode();                                 // Get code.
            if (!code.empty()) {                                                            // If valid...
                p->gameWrapper->SetTimeout([p, code](GameWrapper* gw) {                     // Timeout.
                    p->cvarManager->executeCommand("load_freeplay " + code);
                }, 0.0f);
            }
        } else if (mapType == 1) { // Training                                              // Case: Training.
            int trainingMode = p->settingsSync->GetTrainingMode();                          // Get mode.
            std::string code;
            
            if (trainingMode == 1) { // Bag Rotation                                        // Case: Rotation.
                auto [pack, bagName] = p->AdvanceAndGetNextBagPack();                       // Advance.
                code = pack.code;
            } else { // Single Pack                                                         // Case: Single.
                code = p->settingsSync->GetQuickPicksSelectedCode();                        // Get selected.
                if (code.empty()) code = p->GetCurrentTrainingCode();                       // Fallback.
            }

            if (!code.empty()) {                                                            // If valid...
                if (p->usageTracker) p->usageTracker->IncrementLoadCount(code);             // Track usage.
                p->gameWrapper->SetTimeout([p, code](GameWrapper* gw) {                     // Timeout.
                    p->cvarManager->executeCommand("load_training " + code);
                }, 0.0f);
            }
        } else if (mapType == 2) { // Workshop                                              // Case: Workshop.
            std::string path = p->GetCurrentWorkshopPath();                                 // Get path.
            if (!path.empty()) {                                                            // If valid...
                p->gameWrapper->SetTimeout([p, path](GameWrapper* gw) {                     // Timeout.
                    p->cvarManager->executeCommand("load_workshop \"" + path + "\"");       // Command.
                }, 0.0f);
            }
        }
    }
    if (ImGui::IsItemHovered()) {                                                           // Tooltip.
        ImGui::SetTooltip("Immediately load the currently selected map/pack");              // Text.
    }
}

std::vector<std::string> SettingsUI::GetQuickPicksList() {                                  // GetQuickPicksList implementation.
    std::vector<std::string> defaultCodes;
    for (const auto& p : DefaultPacks::FLICKS_PICKS) {                                      // Loop defaults.
        defaultCodes.push_back(p.code);
    }

    if (!plugin_->usageTracker) return defaultCodes;                                        // Check tracker.

    if (plugin_->usageTracker->IsFirstRun()) {                                              // Check first run.
        return defaultCodes;                                                                // Return defaults.
    }

    int count = plugin_->settingsSync->GetQuickPicksCount();                                // Get count.
    auto topCodes = plugin_->usageTracker->GetTopUsedCodes(count);                          // Get top used.
    
    if (topCodes.empty()) return defaultCodes;                                              // If empty return defaults.
    
    return topCodes;                                                                        // Return top codes.
}

// ======================================================================================
// FILE: TrainingPackUI.h
// ======================================================================================
#pragma once                                                                                // Ensure header is included only once.
#include "IMGUI/imgui.h"                                                                    // Include ImGui library.
#include "bakkesmod/plugin/pluginwindow.h"                                                // Include PluginWindow base class.
#include "MapList.h"                                                                        // Include MapList.
#include "StatusMessageUI.h"                                                                // Include StatusMessage.
#include <string>                                                                           // Include string.
#include <vector>                                                                           // Include vector.
#include <unordered_set>                                                                    // Include unordered_set.
#include <unordered_map>                                                                    // Include unordered_map.
#include <cstring>                                                                          // Include cstring.

// Payload structure for dragging packs FROM bags (includes source bag info)                // Comment: Struct definition.
// This allows the drop target to know where the pack came from for removal                 // Comment: Purpose.
struct BagPackPayload {                                                                     // Struct.
    char packCode[32];                                                                      // Pack code buffer.
    char sourceBag[32];                                                                     // Source bag name buffer.
};                                                                                          // End struct.

/*                                                                                          // Spacer.
 * ======================================================================================   // Comment: Header.
 * TRAINING PACK UI: THE BROWSER WINDOW                                                     // Comment: Title.
 * ======================================================================================   // Comment: Header.
 *                                                                                          // Spacer.
 * WHAT IS THIS?                                                                            // Comment: Section.
 * This class defines the "Training Pack Browser" window. Unlike the Settings UI, this        // Comment: Description.
 * window can float anywhere on your screen and stay open while you play.                   // Comment: Description.
 *                                                                                          // Spacer.
 * WHY IS IT HERE?                                                                          // Comment: Section.
 * Players need a powerful tool to search, sort, and organize hundreds of training packs.   // Comment: Description.
 * A simple dropdown menu isn't enough. This provides a full table view.                    // Comment: Description.
 *                                                                                          // Spacer.
 * HOW DOES IT WORK?                                                                        // Comment: Section.
 * 1. INHERITANCE: It inherits from `PluginWindow`, which tells BakkesMod "I am a separate window." // Comment: Step 1.
 * 2. `Render()`: This function draws the window content (Search bar, Table of packs, Buttons). // Comment: Step 2.
 *    - It uses `ImGui::Columns` to create the table layout.                                // Comment: Detail.
 *    - It uses `ImGuiListClipper` to efficiently draw 2000+ packs without lagging the game. // Comment: Detail.
 * 3. STATE: It remembers your search text, sort order, and which packs you've selected.    // Comment: Step 3.
 */                                                                                         // Spacer.

class SuiteSpot;                                                                            // Forward declaration.

class TrainingPackUI : public BakkesMod::Plugin::PluginWindow {                             // Class definition inheriting from PluginWindow.
public:                                                                                     // Public interface.
    explicit TrainingPackUI(SuiteSpot* plugin);                                             // Constructor.
    
    // PluginWindow implementation                                                          // Comment: Interface implementation.
    // The "Render" function is the main loop that draws the window every frame             // Comment: Description.
    void Render() override;                                                                 // Render override.
    
    // Internal name used by BakkesMod to identify this window (e.g., for console commands) // Comment: Description.
    std::string GetMenuName() override;                                                     // GetMenuName override.
    
    // The title text displayed at the top of the window                                    // Comment: Description.
    std::string GetMenuTitle() override;                                                    // GetMenuTitle override.
    
    // Boilerplate to ensure ImGui knows "where" to draw                                    // Comment: Description.
    void SetImGuiContext(uintptr_t ctx) override;                                           // SetImGuiContext override.
    
    // Control whether the window steals mouse input                                        // Comment: Description.
    bool ShouldBlockInput() override;                                                       // ShouldBlockInput override.
    
    // Check if the window is currently focused                                             // Comment: Description.
    bool IsActiveOverlay() override;                                                        // IsActiveOverlay override.
    
    // Called when the window opens or closes                                               // Comment: Description.
    void OnOpen() override;                                                                 // OnOpen override.
    void OnClose() override;                                                                // OnClose override.

    // Visibility control - Used by the main plugin to toggle this window                   // Comment: Description.
    bool IsOpen();                                                                          // Getter.
    void SetOpen(bool open);                                                                // Setter.

private:                                                                                    // Private members.
    SuiteSpot* plugin_;                                                                     // Plugin pointer.
    bool isWindowOpen_ = false;                                                             // Window open state.
    bool needsFocusOnNextRender_ = false;  // Bring to front when first opened              // Focus request flag.

    char packSearchText[256] = {0};                                                         // Search buffer.
    std::string packDifficultyFilter = "All";                                               // Difficulty filter.
    std::string packTagFilter = "";                                                         // Tag filter.
    int packMinShots = 0;                                                                   // Min shots filter.
    int packMaxShots = 100;                                                                 // Max shots filter.
    int packSortColumn = 0;                                                                 // Sort column index.
    bool packSortAscending = true;                                                          // Sort direction.
    bool packVideoFilter = false;  // Filter for packs with video URLs                      // Video filter.

    char lastSearchText[256] = {0};                                                         // Cache for change detection.
    std::string lastDifficultyFilter = "All";                                               // Cache.
    std::string lastTagFilter = "";                                                         // Cache.
    int lastMinShots = 0;                                                                   // Cache.
    int lastSortColumn = 0;                                                                 // Cache.
    bool lastSortAscending = true;                                                          // Cache.
    bool lastVideoFilter = false;                                                           // Cache.

    std::vector<std::string> availableTags;                                                 // Tags cache.
    bool tagsInitialized = false;                                                           // Init flag.
    int lastPackCount = 0;                                                                  // Count cache.
    std::vector<TrainingEntry> filteredPacks;                                               // Filtered list cache.

    // Selection state                                                                      // Comment: Section.
    std::string selectedPackCode;                                                           // Selected code.
    int lastSelectedRowIndex = -1;                                                          // Selected row.
    bool packListInitialized = false;                                                       // Init flag.

    // Custom pack form state                                                               // Comment: Section.
    char customPackCode[20] = {0};       // XXXX-XXXX-XXXX-XXXX format                      // Input buffer.
    char customPackName[128] = {0};                                                         // Input buffer.
    char customPackCreator[64] = {0};                                                       // Input buffer.
    int customPackDifficulty = 0;        // Index into difficulties array                   // Selection index.
    int customPackShotCount = 10;                                                           // Value.
    char customPackTags[256] = {0};      // Comma-separated                                 // Input buffer.
    char customPackNotes[512] = {0};                                                        // Input buffer.
    char customPackVideoUrl[256] = {0};                                                     // Input buffer.
    UI::StatusMessage customPackStatus;                                                     // Status message.
    UI::StatusMessage browserStatus;                                                        // Status message.

    // Bag manager modal state                                                              // Comment: Section.
    bool showBagManagerModal = false;                                                       // Modal state.
    std::unordered_map<std::string, std::string> selectedPackInBag;  // bagName  packCode  // Selection map.

    // Helper methods                                                                       // Comment: Section.
    void LoadPackImmediately(const std::string& packCode);                                  // Method.
    void RenderCustomPackForm();                                                            // Method.
    void RenderBagManagerModal();                                                           // Method.
    void RenderBagChildWindow(const TrainingBag& bag, float width, float height);           // Method.
    void MoveSelectedPackUp(const std::string& bagName);                                    // Method.
    void MoveSelectedPackDown(const std::string& bagName);                                  // Method.
    bool ValidatePackCode(const char* code) const;                                          // Method.
    void ClearCustomPackForm();                                                             // Method.
    void CalculateOptimalColumnWidths();                                                    // Method.

    // Column sizing state                                                                  // Comment: Section.
    std::vector<float> columnWidths;                                                        // Widths vector.
    bool columnWidthsDirty = true;                                                          // Dirty flag.
    bool columnWidthsInitialized = false;                                                   // Init flag.
    float lastWindowWidth = 0.0f;                                                           // Cache.

    // Icons                                                                                // Comment: Section.
    std::shared_ptr<ImageWrapper> youtubeIcon;                                              // Icon ptr.

    // State sync                                                                           // Comment: Section.
    std::string lastQuickPicksSelected;                                                     // Sync cache.
};                                                                                          // End class.

// ======================================================================================
// FILE: TrainingPackUI.cpp
// ======================================================================================
#include "pch.h"                                                                            // Precompiled header.
#define NOMINMAX                                                                            // Prevent Windows macros min/max.
#include <windows.h>                                                                        // Windows API.
#include <shellapi.h>                                                                       // Shell API (ShellExecute).

#include "TrainingPackUI.h"                                                                 // Header.
#include "TrainingPackManager.h"                                                            // Manager header.
#include "SuiteSpot.h"                                                                      // Main header.
#include "SettingsSync.h"                                                                   // Sync header.
#include "ConstantsUI.h"                                                                    // Constants header.
#include "HelpersUI.h"                                                                      // Helpers header.

#include <algorithm>                                                                        // Algorithm.
#include <cmath>                                                                            // Math.
#include <cstring>                                                                          // CString.
#include <cstdio>                                                                           // CStdIO.

// Helper function for sortable column headers with visual indicators                        // Comment: Helper.
namespace {                                                                                 // Anonymous namespace.
    bool SortableColumnHeader(const char* label, int columnIndex, int& currentSortColumn, bool& sortAscending) { // Function def.
        // Display label with sort indicator if this column is active                       // Comment: Logic.
        // Use ASCII arrows (^ v) since Unicode triangles may not be in the font            // Comment: Reason.
        char buffer[256];                                                                   // Buffer.
        if (currentSortColumn == columnIndex) {                                             // If active sort col...
            snprintf(buffer, sizeof(buffer), "%s %s", label, sortAscending ? "(asc)" : "(desc)"); // Append direction.
        } else {                                                                            // If not active...
            snprintf(buffer, sizeof(buffer), "%s", label);                                  // Just label.
        }

        bool clicked = ImGui::Selectable(buffer, currentSortColumn == columnIndex, ImGuiSelectableFlags_DontClosePopups); // Selectable.
        if (clicked) {                                                                      // If clicked...
            if (currentSortColumn == columnIndex) {                                         // If same col...
                sortAscending = !sortAscending;                                             // Toggle dir.
            } else {                                                                        // If different...
                currentSortColumn = columnIndex;                                            // Set new col.
                sortAscending = true;                                                       // Default asc.
            }
        }
        return clicked;                                                                     // Return click state.
    }
}

TrainingPackUI::TrainingPackUI(SuiteSpot* plugin) : plugin_(plugin) {                       // Constructor.
    auto path = plugin_->GetDataRoot() / "SuiteSpot" / "Resources" / "Icons" / "icon_youtube.png"; // Icon path.
    LOG("SuiteSpot: Attempting to load YouTube icon from: " + path.string());               // Log.
    youtubeIcon = std::make_shared<ImageWrapper>(path.string(), true);                      // Create ImageWrapper.
    youtubeIcon->LoadForImGui([this, path](bool success) {                                  // Load async.
        if (success) {                                                                      // On success...
            LOG("SuiteSpot: YouTube icon loaded successfully.");                            // Log.
        } else {                                                                            // On failure...
            LOG("SuiteSpot: Failed to load YouTube icon from " + path.string());            // Log.
        }
    });
}

void TrainingPackUI::Render() {
    // Render implementation.
    if (!isWindowOpen_) {
        // Check if open.
        return;
        // Exit if closed.
    }

    ImGui::SetNextWindowSize(ImVec2(800, 600), ImGuiCond_FirstUseEver); // Set default size.

    // Bring window to front when first opened // Comment: Focus logic.
    if (needsFocusOnNextRender_) {
        ImGui::SetNextWindowFocus(); // Request focus.
        needsFocusOnNextRender_ = false; // Reset flag.
    }

    // Only prevent bringing to front when bag manager is open // Comment: Logic.
    // This allows normal window interaction (clicking to bring forward) when bag manager is closed // Comment: Context.
    // But keeps browser in back during drag-and-drop when bag manager is visible // Comment: Context.
    ImGuiWindowFlags browserFlags = ImGuiWindowFlags_None; // Default flags.
    if (showBagManagerModal) { // If modal open...
        browserFlags |= ImGuiWindowFlags_NoBringToFrontOnFocus; // Prevent fronting.
    }

    if (!ImGui::Begin(GetMenuTitle().c_str(), &isWindowOpen_, browserFlags)) { // Begin window.
        ImGui::End(); // End if collapsed.
        return; // Exit.
    }

    // Apply font scale to this window // Comment: Scaling.
    ImGui::SetWindowFontScale(UI::FONT_SCALE); // Set scale.

    const auto* manager = plugin_->trainingPackMgr; // Get manager.
    static const std::vector<TrainingEntry> emptyPacks;
    static const std::string emptyString;
    const auto& packs = manager ? manager->GetPacks() : emptyPacks; // Get packs.
    const int packCount = manager ? manager->GetPackCount() : 0; // Get count.
    const auto& lastUpdated = manager ? manager->GetLastUpdated() : emptyString; // Get updated time.
    const bool scraping = manager && manager->IsScrapingInProgress(); // Get scrape status.

    // Sync selection from Quick Picks (Single Source of Truth) // Comment: Sync logic.
    if (plugin_->settingsSync) { // Check sync.
        std::string currentQuickPick = plugin_->settingsSync->GetQuickPicksSelectedCode(); // Get quick pick.
        if (currentQuickPick != lastQuickPicksSelected) { // If changed...
            if (!currentQuickPick.empty()) { // If not empty...
                selectedPackCode = currentQuickPick; // Update selection.
            }
            lastQuickPicksSelected = currentQuickPick; // Update cache.
        }
    }

    // ===== HEADER SECTION ===== // Comment: Header.
    ImGui::TextColored(UI::TrainingPackUI::SECTION_HEADER_TEXT_COLOR, "Training Pack Browser"); // Title.
    ImGui::Spacing(); // Spacing.

    // Status line: pack count, last updated, auto-load, and buttons on same row // Comment: Status.
    if (packCount > 0) { // If packs loaded...
        ImGui::Text("Loaded: %d packs", packCount); // Show count.
        ImGui::SameLine(); // Inline.
        ImGui::TextColored(UI::TrainingPackUI::LAST_UPDATED_TEXT_COLOR, " | Last updated: %s", lastUpdated.c_str()); // Show timestamp.
    } else { // If no packs...
        ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.5f, 1.0f), "No packs loaded - click 'Update Pack List' to download"); // Error text.
    }

    // Control buttons (same line with spacing) // Comment: Buttons.
    ImGui::SameLine(0.0f, 20.0f); // Spacing.
    if (scraping) { // If scraping...
        ImGui::TextColored(UI::TrainingPackUI::SCRAPING_STATUS_TEXT_COLOR, "Updating..."); // Show status.
    } else { // If idle...
        if (ImGui::Button("Update Pack List")) { // Update button.
            plugin_->UpdateTrainingPackList(); // Call update.
        }
        if (ImGui::IsItemHovered()) { // Tooltip.
            ImGui::SetTooltip("Download latest training packs from online source (~2-3 minutes)"); // Text.
        }
    }

    ImGui::SameLine(); // Inline.
    if (ImGui::Button("Reload Cache")) { // Reload button.
        plugin_->LoadTrainingPacksFromFile(plugin_->GetTrainingPacksPath()); // Call reload.
    }
    if (ImGui::IsItemHovered()) { // Tooltip.
        ImGui::SetTooltip("Reload packs from cached json file"); // Text.
    }

    // Load Now button (Immediate load) // Comment: Load Now.
    ImGui::SameLine(); // Inline.
    bool hasSelection = !selectedPackCode.empty(); // Check selection.
    if (!hasSelection) { // If none...
        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f); // Dim button.
    }
    if (ImGui::Button("LOAD NOW") && hasSelection) { // Button logic.
        LoadPackImmediately(selectedPackCode); // Call load.
    }
    if (!hasSelection) { // If dimmed...
        ImGui::PopStyleVar(); // Restore alpha.
    }
    if (ImGui::IsItemHovered()) { // Tooltip.
        ImGui::SetTooltip(hasSelection ? "Immediately load the selected pack" : "Select a pack first"); // Text.
    }

    ImGui::Separator(); // Separator.
    ImGui::Spacing(); // Spacing.

    // Early return if no packs loaded // Comment: Guard.
    if (packs.empty()) { // If empty...
        ImGui::TextWrapped("No packs available. Click 'Scrape Packs' to download the training pack database, or add your own custom packs below."); // Help text.
        ImGui::End(); // End window.
        return; // Exit.
    }

    // ===== BAG MANAGER STATUS & CONTROLS ===== // Comment: Bag section.
    if (ImGui::CollapsingHeader("Bag Manager", ImGuiTreeNodeFlags_DefaultOpen)) { // Header.
        const auto& bags = manager ? manager->GetAvailableBags() : std::vector<TrainingBag>(); // Get bags.

        // Count total packs across all enabled bags // Comment: Counting.
        int totalPacksInBags = 0; // Total.
        int enabledBagCount = 0; // Enabled count.
        for (const auto& bag : bags) { // Loop bags.
            if (bag.enabled) { // If enabled...
                totalPacksInBags += manager ? manager->GetBagPackCount(bag.name) : 0; // Add count.
                enabledBagCount++; // Inc count.
            }
        }

        if (totalPacksInBags > 0) { // If packs exist...
            ImGui::TextColored(UI::TrainingPackUI::BAG_ROTATION_STATUS_COLOR, // Colored text.
                "Rotation: %d pack%s in %d bag%s", // Format string.
                totalPacksInBags, totalPacksInBags == 1 ? "" : "s", // Format args.
                enabledBagCount, enabledBagCount == 1 ? "" : "s"); // Format args.


        } else { // If no packs...
            ImGui::TextDisabled("No packs in rotation bags"); // Disabled text.
            ImGui::TextWrapped("Add packs to bags using the 'Add to Bag' button below, or right-click a pack row."); // Help text.
        }

        // Show bag summary in a compact row // Comment: Summary.
        ImGui::Spacing(); // Spacing.
        ImGui::TextUnformatted("Bags:"); // Label.
        ImGui::SameLine(); // Inline.
        for (const auto& bag : bags) { // Loop bags.
            int bagCount = manager ? manager->GetBagPackCount(bag.name) : 0; // Get count.
            if (bagCount > 0) { // If not empty...
                ImVec4 badgeColor(bag.color[0], bag.color[1], bag.color[2], bag.color[3]); // Get color.
                ImGui::TextColored(badgeColor, "%s (%d)", bag.name.c_str(), bagCount); // Show badge.
                ImGui::SameLine(); // Inline.
            }
        }
        ImGui::NewLine(); // New line.

        ImGui::SameLine(); // Inline.
        if (ImGui::Button("Manage Bags...")) { // Manage button.
            showBagManagerModal = true; // Show modal.
        }
        if (ImGui::IsItemHovered()) { // Tooltip.
            ImGui::SetTooltip("Open bag manager to enable/disable bags and adjust rotation order"); // Text.
        }

        ImGui::Spacing(); // Spacing.
    }

    // Render bag manager modal (after the collapsing header) // Comment: Modal.
    RenderBagManagerModal(); // Call render.

    ImGui::Separator(); // Separator.
    ImGui::Spacing(); // Spacing.

    // ===== ADD CUSTOM PACK SECTION ===== // Comment: Custom Pack.
    RenderCustomPackForm(); // Call render.

    ImGui::Separator(); // Separator.
    ImGui::Spacing(); // Spacing.

    // Early return if no packs loaded // Comment: Guard.
    if (packs.empty()) { // If empty...
        ImGui::TextWrapped("No packs available. Click 'Scrape Packs' to download the training pack database, or add your own custom packs above."); // Help text.
        ImGui::End(); // End.
        return; // Exit.
    }

    // ===== FILTER & SEARCH CONTROLS ===== // Comment: Filters.
    ImGui::TextUnformatted("Search & Filters:"); // Header.
    ImGui::Spacing(); // Spacing.

    bool filtersChanged = (strcmp(packSearchText, lastSearchText) != 0) || // Check changes.
                          (packDifficultyFilter != lastDifficultyFilter) || // ...
                          (packTagFilter != lastTagFilter) || // ...
                          (packMinShots != lastMinShots) || // ...
                          (packSortColumn != lastSortColumn) || // ...
                          (packSortAscending != lastSortAscending) || // ...
                          (packVideoFilter != lastVideoFilter); // ...

    // Fixed widths for filter controls // Comment: Layout.
    // Search box // Comment: Search.
    ImGui::SetNextItemWidth(200.0f); // Width.
    if (ImGui::InputText("##search", packSearchText, IM_ARRAYSIZE(packSearchText))) { // Input.
        filtersChanged = true; // Set changed.
    }
    if (ImGui::IsItemHovered()) { // Tooltip.
        ImGui::SetTooltip("Search by pack name, creator, or tag"); // Text.
    }

    // Difficulty filter // Comment: Difficulty.
    ImGui::SameLine(); // Inline.
    ImGui::SetNextItemWidth(150.0f); // Width.
    const char* difficulties[] = {"All", "Unranked", "Bronze", "Silver", "Gold", "Platinum", "Diamond", "Champion", "Grand Champion", "Supersonic Legend"}; // Options.
    if (ImGui::BeginCombo("##difficulty", packDifficultyFilter.c_str())) { // Combo.
        for (int i = 0; i < IM_ARRAYSIZE(difficulties); i++) { // Loop.
            bool selected = (packDifficultyFilter == difficulties[i]); // Check selected.
            if (ImGui::Selectable(difficulties[i], selected)) { // Selectable.
                packDifficultyFilter = difficulties[i]; // Update.
                filtersChanged = true; // Set changed.
            }
        }
        ImGui::EndCombo(); // End.
    }
    if (ImGui::IsItemHovered()) { // Tooltip.
        ImGui::SetTooltip("Filter by difficulty level"); // Text.
    }

    // Shot count range filter // Comment: Shots.
    ImGui::SameLine(); // Inline.
    ImGui::SetNextItemWidth(150.0f); // Width.
    if (ImGui::SliderInt("Min Shots", &packMinShots, UI::TrainingPackUI::FILTER_MIN_SHOTS_MIN, UI::TrainingPackUI::FILTER_MIN_SHOTS_MAX)) { // Slider.
        filtersChanged = true; // Set changed.
    }
    if (ImGui::IsItemHovered()) { // Tooltip.
        ImGui::SetTooltip("Minimum number of shots in pack"); // Text.
    }

    // Tag filter dropdown (second row) // Comment: Tags.
    ImGui::SetNextItemWidth(UI::TrainingPackUI::TAG_FILTER_DROPDOWN_WIDTH); // Width.

    bool packsSourceChanged = (lastPackCount != packCount); // Check count change.

    if (!tagsInitialized || packsSourceChanged) { // If refresh needed...
        if (manager) { // If manager...
            manager->BuildAvailableTags(availableTags); // Build tags.
        } else { // Else...
            availableTags.clear(); // Clear.
            availableTags.push_back("All Tags"); // Default.
        }
        tagsInitialized = true; // Set init.
        lastPackCount = packCount; // Update count.
    }

    std::string displayTag = packTagFilter.empty() ? "All Tags" : packTagFilter; // Display string.
    if (ImGui::BeginCombo("##tagfilter", displayTag.c_str())) { // Combo.
        for (const auto& tag : availableTags) { // Loop tags.
            bool selected = (tag == displayTag); // Check selected.
            if (ImGui::Selectable(tag.c_str(), selected)) { // Selectable.
                packTagFilter = (tag == "All Tags") ? "" : tag; // Update.
                filtersChanged = true; // Set changed.
            }
        }
        ImGui::EndCombo(); // End.
    }
    if (ImGui::IsItemHovered()) { // Tooltip.
        ImGui::SetTooltip("Filter by tag"); // Text.
    }

    ImGui::SameLine(); // Inline.

    // Video filter checkbox // Comment: Video.
    if (ImGui::Checkbox("Has Video", &packVideoFilter)) { // Checkbox.
        filtersChanged = true; // Set changed.
    }
    if (ImGui::IsItemHovered()) { // Tooltip.
        ImGui::SetTooltip("Show only packs with video tutorials"); // Text.
    }

    ImGui::SameLine(); // Inline.
    if (ImGui::Button("Clear Filters")) { // Clear button.
        packSearchText[0] = '\0'; // Clear search.
        packDifficultyFilter = "All"; // Clear diff.
        packTagFilter = ""; // Clear tag.
        packMinShots = 0; // Clear shots.
        packMaxShots = 100; // Reset shots.
        packVideoFilter = false; // Clear video.
        filtersChanged = true; // Set changed.
    }

    ImGui::Spacing(); // Spacing.
    ImGui::Separator(); // Separator.
    ImGui::Spacing(); // Spacing.

    // ===== FILTERED & SORTED PACK LIST (cached) ===== // Comment: Filter list.

    // Rebuild filtered list only when needed // Comment: Optimization.
    if (filtersChanged || packsSourceChanged || !packListInitialized) { // If update needed...
        if (manager) { // If manager...
            manager->FilterAndSortPacks(packSearchText, packDifficultyFilter, packTagFilter, // Call sort.
                packMinShots, packVideoFilter, packSortColumn, packSortAscending, filteredPacks); // ...
        } else { // Else...
            filteredPacks.clear(); // Clear.
        }

        // Update cached filter state // Comment: Update cache.
        strncpy_s(lastSearchText, packSearchText, sizeof(lastSearchText) - 1); // Cache search.
        lastDifficultyFilter = packDifficultyFilter; // Cache diff.
        lastTagFilter = packTagFilter; // Cache tag.
        lastMinShots = packMinShots; // Cache shots.
        lastVideoFilter = packVideoFilter; // Cache video.
        lastSortColumn = packSortColumn; // Cache sort col.
        lastSortAscending = packSortAscending; // Cache sort dir.

        // Flag to recalculate column widths // Comment: Layout.
        columnWidthsDirty = true; // Set dirty.
        packListInitialized = true; // Set init.
    }

    // Display filtered count // Comment: Stats.
    ImGui::Text("Showing %d of %d packs", (int)filteredPacks.size(), packCount); // Show count.
    ImGui::Spacing(); // Spacing.

    // ===== ACTION BAR ===== // Comment: Actions.
    ImGui::Separator(); // Separator.

    // Render browser status message // Comment: Status.
    browserStatus.Render(ImGui::GetIO().DeltaTime); // Render status.
    if (browserStatus.IsVisible()) ImGui::Spacing(); // Spacing.

    {
        bool hasSelection = !selectedPackCode.empty(); // Check selection.
        
        // Find selected pack data // Comment: Lookup.
        const TrainingEntry* selectedPack = nullptr; // Pointer.
        if (hasSelection) { // If selected...
            for (const auto& pack : filteredPacks) { // Loop.
                if (pack.code == selectedPackCode) { // Match.
                    selectedPack = &pack; // Set pointer.
                    break; // Break.
                }
            }
        }

        // Delete (Custom only) // Comment: Delete.
        if (hasSelection) { // If selected...
             if (ImGui::Button("Delete Custom Pack")) { // Button.
                 if (plugin_->trainingPackMgr) { // If manager...
                     plugin_->trainingPackMgr->DeletePack(selectedPackCode); // Call delete.
                     browserStatus.ShowSuccess("Deleted custom pack", 3.0f, UI::StatusMessage::DisplayMode::TimerWithFade); // Success.
                     selectedPackCode = ""; // Clear selection.
                 }
             }
        } else { // If no selection...
            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f); // Dim.
            ImGui::Button("Delete Custom Pack"); // Button.
            ImGui::PopStyleVar(); // Restore.
        }

        ImGui::SameLine(); // Inline.

        // Clear Selection // Comment: Clear.
        if (hasSelection) { // If selected...
            if (ImGui::Button("Clear Selection")) { // Button.
                selectedPackCode = ""; // Clear.
            }
        } else { // If no selection...
            ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f); // Dim.
            ImGui::Button("Clear Selection"); // Button.
            ImGui::PopStyleVar(); // Restore.
        }
    }

    // ===== TABLE WITH RESIZABLE COLUMNS & FROZEN HEADER ===== // Comment: Table.
    ImGui::Separator(); // Separator.

    // Only set initial column widths once, or when window width changes significantly // Comment: Layout logic.
    // This allows users to manually resize columns by dragging // Comment: Context.
    float currentWindowWidth = ImGui::GetWindowContentRegionWidth(); // Get width.
    bool windowResized = std::abs(currentWindowWidth - lastWindowWidth) > 50.0f; // Check resize.

    if (!columnWidthsInitialized || windowResized) { // If recalc needed...
        CalculateOptimalColumnWidths(); // Recalc.
        columnWidthsInitialized = true; // Set init.
        lastWindowWidth = currentWindowWidth; // Update cache.
    }

    // ===== FROZEN HEADER ROW ===== // Comment: Headers.
    ImGui::Columns(UI::TrainingPackUI::TABLE_COLUMN_COUNT, "PackColumns_Header", true); // Begin cols.

    for (int i = 0; i < 5 && i < (int)columnWidths.size(); i++) { // Loop cols.
        ImGui::SetColumnWidth(i, columnWidths[i]); // Set width.
    }

    // Name column header (Sort ID 0) // Comment: Name Header.
    if (SortableColumnHeader("Name", 0, packSortColumn, packSortAscending)) { // Draw header.
        filtersChanged = true; // Set changed.
    }
    ImGui::NextColumn(); // Next.

    // Difficulty column header (Sort ID 2) // Comment: Diff Header.
    if (SortableColumnHeader("Difficulty", 2, packSortColumn, packSortAscending)) { // Draw header.
        filtersChanged = true; // Set changed.
    }
    ImGui::NextColumn();

    // Shots column header (Sort ID 3) // Comment: Shots Header.
    if (SortableColumnHeader("Shots", 3, packSortColumn, packSortAscending)) { // Draw header.
        filtersChanged = true; // Set changed.
    }
    ImGui::NextColumn(); // Next.

    // Likes column header (Sort ID 4) // Comment: Likes Header.
    if (SortableColumnHeader("Likes", 4, packSortColumn, packSortAscending)) { // Draw header.
        filtersChanged = true; // Set changed.
    }
    ImGui::NextColumn(); // Next.

    // Plays column header (Sort ID 5) // Comment: Plays Header.
    if (SortableColumnHeader("Plays", 5, packSortColumn, packSortAscending)) { // Draw header.
        filtersChanged = true; // Set changed.
    }
    ImGui::NextColumn(); // Next.

    ImGui::Columns(1); // Reset.
    ImGui::Separator(); // Separator.

    // ===== SCROLLABLE PACK ROWS ===== // Comment: Rows.
    ImGui::BeginChild("PackTable", ImVec2(0, -ImGui::GetFrameHeightWithSpacing()), false, ImGuiWindowFlags_HorizontalScrollbar); // Begin scroll area.

    ImGui::Columns(UI::TrainingPackUI::TABLE_COLUMN_COUNT, "PackColumns_Body", true); // Begin cols.

    for (int i = 0; i < 5 && i < (int)columnWidths.size(); i++) { // Loop cols.
        ImGui::SetColumnWidth(i, columnWidths[i]); // Set width.
    }

    ImGuiListClipper clipper; // Clipper.
    clipper.Begin((int)filteredPacks.size()); // Begin clipper.

    while (clipper.Step()) // Clipper loop.
    {
        for (int row = clipper.DisplayStart; row < clipper.DisplayEnd; row++) // Row loop.
        {
            const auto& pack = filteredPacks[row]; // Get pack.

            // Name column with Selection Logic // Comment: Name Col.
            bool isSelected = (selectedPackCode == pack.code); // Check selected.
            ImGui::PushID(pack.code.c_str()); // Push ID.

            // Play Button (if video exists) // Comment: Play button.
            if (!pack.videoUrl.empty()) { // If video...
                bool clicked = false; // Click flag.
                if (youtubeIcon && youtubeIcon->IsLoadedForImGui()) { // If icon loaded...
                    if (ImGui::ImageButton(youtubeIcon->GetImGuiTex(), ImVec2(ImGui::GetFrameHeight(), ImGui::GetFrameHeight()))) { // Image button.
                        clicked = true; // Set clicked.
                    }
                } else { // Fallback.
                    if (ImGui::ArrowButton("##play", ImGuiDir_Right)) { // Arrow button.
                        clicked = true; // Set clicked.
                    }
                }

                if (clicked) { // If clicked...
                    ShellExecuteA(NULL, "open", pack.videoUrl.c_str(), NULL, NULL, SW_SHOWNORMAL); // Open URL.
                }
                if (ImGui::IsItemHovered()) ImGui::SetTooltip("Watch Preview"); // Tooltip.
                ImGui::SameLine(); // Inline.
            } else { // If no video...
                // Indent to align with packs that have buttons (approximate width of ArrowButton + Spacing) // Comment: Alignment.
                ImGui::Dummy(ImVec2(ImGui::GetFrameHeight(), 0)); // Spacer.
                ImGui::SameLine(); // Inline.
            }

            // SpanAllColumns allows clicking anywhere in the row // Comment: Selectable.
            if (ImGui::Selectable(pack.name.c_str(), isSelected, ImGuiSelectableFlags_SpanAllColumns)) { // Selectable.
                selectedPackCode = pack.code; // Update selection.
                lastSelectedRowIndex = row; // Update index.
                ImGui::OpenPopup("PackActionPopup"); // Open context menu.
            }

            if (ImGui::BeginPopup("PackActionPopup")) { // Context Menu.
                const auto& trainingPacks = manager ? manager->GetPacks() : emptyPacks; // Get packs.
                auto it = std::find_if(trainingPacks.begin(), trainingPacks.end(), // Find pack.
                    [&](const TrainingEntry& e) { return e.code == selectedPackCode; }); // ...

                if (it != trainingPacks.end()) { // If found...
                    ImGui::TextColored(UI::TrainingPackUI::SECTION_HEADER_TEXT_COLOR, "%s", it->name.c_str()); // Title.
                    ImGui::Separator(); // Separator.

                    if (ImGui::Selectable("Set Post-Match")) { // Option.
                        plugin_->settingsSync->SetQuickPicksSelected(selectedPackCode); // Set sync.
                        plugin_->cvarManager->getCvar("suitespot_quickpicks_selected").setValue(selectedPackCode); // Set CVar.
                        // Also sync with current training code for consistency // Comment.
                        plugin_->settingsSync->SetCurrentTrainingCode(selectedPackCode); // Set sync.
                        plugin_->cvarManager->getCvar("suitespot_current_training_code").setValue(selectedPackCode); // Set CVar.
                        browserStatus.ShowSuccess("Post-Match set: " + it->name, 2.0f, UI::StatusMessage::DisplayMode::TimerWithFade); // Status.
                    }

                    if (ImGui::BeginMenu("Add to Bag...")) { // Submenu.
                        const auto& bags = manager ? manager->GetAvailableBags() : std::vector<TrainingBag>(); // Get bags.
                        for (const auto& bag : bags) { // Loop bags.
                            if (ImGui::Selectable(bag.name.c_str())) { // Option.
                                plugin_->trainingPackMgr->AddPackToBag(selectedPackCode, bag.name); // Add.
                                browserStatus.ShowSuccess("Added to " + bag.name, 2.0f, UI::StatusMessage::DisplayMode::TimerWithFade); // Status.
                            }
                        }
                        ImGui::EndMenu(); // End submenu.
                    }

                    if (ImGui::Selectable("Load Now")) { // Option.
                        if (plugin_->usageTracker) plugin_->usageTracker->IncrementLoadCount(selectedPackCode); // Track.
                        std::string code = selectedPackCode; // Store.
                        std::string name = it->name; // Store.
                        SuiteSpot* p = plugin_; // Alias.
                        p->gameWrapper->SetTimeout([p, code, name](GameWrapper* gw) { // Timeout.
                            p->cvarManager->executeCommand("load_training " + code); // Command.
                            LOG("SuiteSpot: Loading training pack from browser: " + name); // Log.
                        }, 0.0f); // Immediate.
                    }
                }
                ImGui::EndPopup(); // End popup.
            }

            // === DRAG SOURCE for drag-and-drop to bag manager === // Comment: Drag.
            if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None)) { // Begin source.
                // Payload: pack code as null-terminated string // Comment: Payload.
                ImGui::SetDragDropPayload("TRAINING_PACK_CODE", pack.code.c_str(), pack.code.length() + 1); // Set payload.

                // Preview during drag // Comment: Preview.
                ImGui::TextColored(ImVec4(0.5f, 0.8f, 1.0f, 1.0f), "Dragging: %s", pack.name.c_str()); // Text.

                ImGui::EndDragDropSource(); // End source.
            }

            // Right-click context menu for auto-load // Comment: Context menu.
            if (ImGui::BeginPopupContextItem(("PackContext_" + pack.code).c_str())) { // Begin popup.
                ImGui::TextColored(UI::TrainingPackUI::SECTION_HEADER_TEXT_COLOR, "%s", pack.name.c_str()); // Title.
                ImGui::Separator(); // Separator.

                // Set as Auto-Load option // Comment.
                if (ImGui::Selectable("Set as Auto-Load")) { // Option.
                    plugin_->settingsSync->SetCurrentTrainingCode(pack.code); // Sync.
                    plugin_->cvarManager->getCvar("suitespot_current_training_code").setValue(pack.code); // CVar.
                    browserStatus.ShowSuccess("Auto-Load set: " + pack.name, 2.0f, UI::StatusMessage::DisplayMode::TimerWithFade); // Status.
                }
                ImGui::EndPopup(); // End popup.
            }

            ImGui::PopID(); // Pop ID.
            if (ImGui::IsItemHovered()) { // Tooltip.
                std::string tooltip = ""; // Builder.
                if (!pack.staffComments.empty()) tooltip += pack.staffComments + "\n"; // Comments.
                if (!pack.creator.empty()) tooltip += "Creator: " + pack.creator + "\n"; // Creator.
                if (!pack.tags.empty()) { // Tags.
                    tooltip += "Tags: "; // Label.
                    for (size_t i = 0; i < pack.tags.size(); i++) { // Loop.
                        if (i > 0) tooltip += ", "; // Comma.
                        tooltip += pack.tags[i]; // Tag.
                    }
                }
                if (!tooltip.empty()) { // If content...
                    ImVec2 mPos = ImGui::GetMousePos(); // Mouse pos.
                    ImGui::SetNextWindowPos(ImVec2(mPos.x + 20, mPos.y + 20)); // Pos.
                    ImGui::BeginTooltip(); // Begin.
                    ImGui::PushTextWrapPos(450.0f); // Wrap.
                    ImGui::TextUnformatted(tooltip.c_str()); // Text.
                    ImGui::PopTextWrapPos(); // Pop.
                    ImGui::EndTooltip(); // End.
                }
            }
            ImGui::NextColumn(); // Next col.

            // Difficulty column with color coding // Comment: Diff Col.
            ImVec4 diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_UNRANKED_COLOR; // Default color.
            std::string displayDifficulty = pack.difficulty; // Get string.
            
            if (displayDifficulty.empty() || displayDifficulty == "Unknown" || displayDifficulty == "All") { // Normalize.
                displayDifficulty = "Unranked"; // Default.
            }

            if (displayDifficulty == "Bronze") diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_BRONZE_COLOR; // Color map.
            else if (displayDifficulty == "Silver") diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_SILVER_COLOR; // ...
            else if (displayDifficulty == "Gold") diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_GOLD_COLOR; // ...
            else if (displayDifficulty == "Platinum") diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_PLATINUM_COLOR; // ...
            else if (displayDifficulty == "Diamond") diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_DIAMOND_COLOR; // ...
            else if (displayDifficulty == "Champion") diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_CHAMPION_COLOR; // ...
            else if (displayDifficulty == "Grand Champion") diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_GRAND_CHAMPION_COLOR; // ...
            else if (displayDifficulty == "Supersonic Legend") diffColor = UI::TrainingPackUI::DIFFICULTY_BADGE_SUPERSONIC_LEGEND_COLOR; // ...
            
            ImGui::TextColored(diffColor, "%s", displayDifficulty.c_str()); // Draw text.
            ImGui::NextColumn(); // Next col.

            // Shots column // Comment: Shots.
            ImGui::Text("%d", pack.shotCount); // Text.
            ImGui::NextColumn(); // Next col.

            // Likes column // Comment: Likes.
            ImGui::Text("%d", pack.likes); // Text.
            ImGui::NextColumn(); // Next col.

            // Plays column // Comment: Plays.
            ImGui::Text("%d", pack.plays); // Text.
            ImGui::NextColumn(); // Next col.
        }
    }

    // End columns // Comment: End.
    ImGui::Columns(1); // Reset.
    ImGui::EndChild(); // End scroll.

    ImGui::Spacing(); // Spacing.
    ImGui::End(); // End window.
}

void TrainingPackUI::RenderBagManagerModal() {                                              // RenderBagManagerModal implementation.
    if (!showBagManagerModal) return;                                                       // Check visibility.

    // Use a separate floating window instead of a modal popup                              // Comment: Logic.
    // This allows interaction with the browser window for drag-and-drop                    // Comment: Context.
    ImGui::SetNextWindowSize(ImVec2(900, 600), ImGuiCond_FirstUseEver);                     // Size.
    if (ImGui::Begin("Bag Manager", &showBagManagerModal, ImGuiWindowFlags_None)) {         // Begin.
        ImGui::TextWrapped("Drag training packs from the browser into any bag below. Use up/down arrows to reorder packs within a bag."); // Help.
        ImGui::Separator();                                                                 // Separator.
        ImGui::Spacing();                                                                   // Spacing.

        const auto* manager = plugin_->trainingPackMgr;                                     // Manager.
        const auto& bags = manager ? manager->GetAvailableBags() : std::vector<TrainingBag>(); // Bags.

        // Calculate child window dimensions                                                // Comment: Layout.
        ImGuiStyle& style = ImGui::GetStyle();                                              // Style.
        float childWidth = (ImGui::GetContentRegionAvail().x - 2 * style.ItemSpacing.x) / 3.0f; // Width / 3.
        float childHeight = 250.0f;                                                         // Fixed height.

        // Render 6 bags in 3x2 grid                                                        // Comment: Grid.
        for (int bagIdx = 0; bagIdx < 6 && bagIdx < (int)bags.size(); bagIdx++) {           // Loop bags.
            const auto& bag = bags[bagIdx];                                                 // Get bag.

            // Layout: 3 per row                                                            // Comment: Row logic.
            if (bagIdx % 3 != 0) ImGui::SameLine();                                         // Same line if not start of row.

            ImGui::PushID(bagIdx);                                                          // Push ID.
            RenderBagChildWindow(bag, childWidth, childHeight);                             // Render bag.
            ImGui::PopID();                                                                 // Pop ID.
        }

        // === REMOVE ZONE ===                                                              // Comment: Remove zone.
        ImGui::Spacing();                                                                   // Spacing.
        ImGui::Separator();                                                                 // Separator.
        ImGui::Spacing();                                                                   // Spacing.

        // Red drop zone for removing packs from bags                                       // Comment: Logic.
        ImVec2 removeZoneSize(ImGui::GetContentRegionAvail().x, 40.0f);                     // Size.
        ImGui::PushStyleColor(ImGuiCol_Button, ImVec4(0.5f, 0.15f, 0.15f, 0.6f));           // Red bg.
        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.7f, 0.2f, 0.2f, 0.8f));      // Hover red.
        ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.8f, 0.25f, 0.25f, 1.0f));     // Active red.

        ImGui::Button("Drop here to remove from bag", removeZoneSize);                      // Drop target button.

        ImGui::PopStyleColor(3);                                                            // Pop colors.

        // Accept drops from bags (PACK_FROM_BAG only - not browser packs)                  // Comment: DragDrop.
        if (ImGui::BeginDragDropTarget()) {                                                 // Begin target.
            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("PACK_FROM_BAG")) { // Accept payload.
                const BagPackPayload* data = (const BagPackPayload*)payload->Data;          // Cast data.
                if (plugin_->trainingPackMgr) {                                             // Check manager.
                    plugin_->trainingPackMgr->RemovePackFromBag(data->packCode, data->sourceBag); // Remove.
                    browserStatus.ShowSuccess("Removed from " + std::string(data->sourceBag), 2.0f, // Success.
                        UI::StatusMessage::DisplayMode::TimerWithFade);                     // ...
                }
            }
            ImGui::EndDragDropTarget();                                                     // End target.
        }

        ImGui::Spacing();                                                                   // Spacing.
        if (ImGui::Button("Close", ImVec2(120, 0))) {                                       // Close button.
            showBagManagerModal = false;                                                    // Close.
        }

        ImGui::End();                                                                       // End window.
    }
}

void TrainingPackUI::RenderBagChildWindow(const TrainingBag& bag, float width, float height) { // RenderBagChildWindow implementation.
    const auto* manager = plugin_->trainingPackMgr;                                         // Manager.

    // Get packs in this bag                                                                // Comment.
    auto packsInBag = manager ? manager->GetPacksInBag(bag.name) : std::vector<TrainingEntry>(); // Get packs.

    // Bag header with icon and color                                                       // Comment.
    ImVec4 bagColor(bag.color[0], bag.color[1], bag.color[2], bag.color[3]);                // Color.
    ImGui::PushStyleColor(ImGuiCol_Border, bagColor);                                       // Border color.

    ImGui::BeginChild(bag.name.c_str(), ImVec2(width, height), true);                       // Begin child.

    // === HEADER (Row 1: Name + Active checkbox) ===                                       // Comment: Header.
    ImGui::TextColored(bagColor, "%s", bag.name.c_str());                                   // Name.
    ImGui::SameLine();                                                                      // Inline.

    // Active checkbox                                                                      // Comment.
    bool enabled = bag.enabled;                                                             // State.
    if (ImGui::Checkbox("##Active", &enabled)) {                                            // Checkbox.
        if (manager) {                                                                      // If manager...
            plugin_->trainingPackMgr->SetBagEnabled(bag.name, enabled);                     // Update.
        }
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Include this bag in rotation");          // Tooltip.

    ImGui::SameLine();                                                                      // Inline.
    ImGui::TextDisabled("(%d)", (int)packsInBag.size());                                    // Count.

    // === HEADER (Row 2: Action buttons) ===                                               // Comment: Actions.
    // Play button - loads first pack in bag                                                // Comment.
    bool bagEmpty = packsInBag.empty();                                                     // Check empty.
    if (bagEmpty) ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f); // Dim.
    if (ImGui::SmallButton("Play")) {                                                       // Button.
        if (!bagEmpty && plugin_) {                                                         // If valid...
            // Set current bag state via CVars                                              // Comment.
            auto currentBagCvar = plugin_->cvarManager->getCvar("suitespot_current_bag");   // Get CVar.
            if (currentBagCvar) currentBagCvar.setValue(bag.name);                          // Set.

            auto currentIdxCvar = plugin_->cvarManager->getCvar("suitespot_current_bag_pack_index"); // Get CVar.
            if (currentIdxCvar) currentIdxCvar.setValue(0);                                 // Set 0.

            // Load first pack                                                              // Comment.
            std::string code = packsInBag[0].code;                                          // Code.
            std::string name = packsInBag[0].name;                                          // Name.
            SuiteSpot* p = plugin_;                                                         // Alias.
            p->gameWrapper->SetTimeout([p, code, name](GameWrapper* gw) {                   // Timeout.
                std::string cmd = "load_training " + code;
                p->cvarManager->executeCommand(cmd);                                        // Execute.
                LOG("SuiteSpot: Playing bag pack: {}", name);                               // Log.
            }, 0.0f);                                                                       // Immediate.

            browserStatus.ShowSuccess("Playing: " + packsInBag[0].name, 2.0f,               // Status.
                UI::StatusMessage::DisplayMode::TimerWithFade);                             // ...
        }
    }
    if (bagEmpty) ImGui::PopStyleVar();                                                     // Pop alpha.
    if (ImGui::IsItemHovered()) {                                                           // Tooltip.
        ImGui::SetTooltip(bagEmpty ? "Bag is empty" : "Load first pack and set as current bag"); // Text.
    }

    ImGui::SameLine();                                                                      // Inline.

    // Empty button - clears all packs from bag                                             // Comment.
    if (bagEmpty) ImGui::PushStyleVar(ImGuiStyleVar_Alpha, ImGui::GetStyle().Alpha * 0.5f); // Dim.
    if (ImGui::SmallButton("Empty")) {                                                      // Button.
        if (!bagEmpty) {                                                                    // If valid...
            // Store bag name for confirmation popup (unique per bag)                       // Comment.
            ImGui::OpenPopup(("ConfirmEmptyBag_" + bag.name).c_str());                      // Open popup.
        }
    }
    if (bagEmpty) ImGui::PopStyleVar();                                                     // Pop alpha.
    if (ImGui::IsItemHovered()) {                                                           // Tooltip.
        ImGui::SetTooltip(bagEmpty ? "Bag is already empty" : "Remove all packs from this bag"); // Text.
    }

    // Confirmation popup for Empty                                                         // Comment: Popup.
    if (ImGui::BeginPopupModal(("ConfirmEmptyBag_" + bag.name).c_str(), nullptr, ImGuiWindowFlags_AlwaysAutoResize)) { // Begin.
        ImGui::Text("Remove all %d packs from %s?", (int)packsInBag.size(), bag.name.c_str()); // Text.
        ImGui::Separator();                                                                 // Separator.

        if (ImGui::Button("Yes, Empty Bag", ImVec2(120, 0))) {                              // Yes button.
            if (plugin_->trainingPackMgr) {                                                 // Manager.
                plugin_->trainingPackMgr->ClearBag(bag.name);                               // Clear.
                browserStatus.ShowSuccess("Cleared " + bag.name, 2.0f,                      // Status.
                    UI::StatusMessage::DisplayMode::TimerWithFade);                         // ...
            }
            ImGui::CloseCurrentPopup();                                                     // Close.
        }
        ImGui::SameLine();                                                                  // Inline.
        if (ImGui::Button("Cancel", ImVec2(80, 0))) {                                       // Cancel button.
            ImGui::CloseCurrentPopup();                                                     // Close.
        }
        ImGui::EndPopup();                                                                  // End.
    }

    ImGui::SameLine();                                                                      // Inline.

    // Up/Down arrow buttons for reordering                                                 // Comment: Reorder.
    if (ImGui::ArrowButton("##up", ImGuiDir_Up)) {                                          // Up.
        MoveSelectedPackUp(bag.name);                                                       // Move up.
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Move selected pack up");                 // Tooltip.

    ImGui::SameLine();                                                                      // Inline.
    if (ImGui::ArrowButton("##down", ImGuiDir_Down)) {                                      // Down.
        MoveSelectedPackDown(bag.name);                                                     // Move down.
    }
    if (ImGui::IsItemHovered()) ImGui::SetTooltip("Move selected pack down");               // Tooltip.

    ImGui::Separator();                                                                     // Separator.

    // === PACK LIST (Scrollable) ===                                                       // Comment: List.
    if (packsInBag.empty()) {                                                               // If empty...
        ImGui::TextDisabled("Drop packs here");                                             // Text.

        // Make the "Drop packs here" text a drop target                                    // Comment: Drop target.
        if (ImGui::BeginDragDropTarget()) {                                                 // Begin target.
            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("TRAINING_PACK_CODE")) { // Accept browser.
                const char* packCode = (const char*)payload->Data;                          // Cast.
                if (manager) {                                                              // Manager.
                    plugin_->trainingPackMgr->AddPackToBag(packCode, bag.name);             // Add.
                    browserStatus.ShowSuccess("Added to " + bag.name, 2.0f,                 // Status.
                        UI::StatusMessage::DisplayMode::TimerWithFade);                     // ...
                }
            }
            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("PACK_FROM_BAG")) { // Accept bag.
                const BagPackPayload* data = (const BagPackPayload*)payload->Data;          // Cast.
                if (manager && std::string(data->sourceBag) != bag.name) {                  // Check self.
                    plugin_->trainingPackMgr->AddPackToBag(data->packCode, bag.name);       // Add.
                    browserStatus.ShowSuccess("Added to " + bag.name, 2.0f,                 // Status.
                        UI::StatusMessage::DisplayMode::TimerWithFade);                     // ...
                }
            }
            ImGui::EndDragDropTarget();                                                     // End.
        }
    } else {                                                                                // If not empty...
        // Render each pack in the bag                                                      // Comment.
        for (int i = 0; i < (int)packsInBag.size(); i++) {                                  // Loop packs.
            const auto& pack = packsInBag[i];                                               // Get pack.

            // Selectable pack row                                                          // Comment.
            bool isSelected = selectedPackInBag[bag.name] == pack.code;                     // Check selection.
            if (ImGui::Selectable(pack.name.c_str(), isSelected)) {                         // Selectable.
                selectedPackInBag[bag.name] = pack.code;                                    // Set selection.
            }

            // === DRAG SOURCE: Allow dragging packs out of bags ===                        // Comment: Drag out.
            if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_None)) {                      // Begin source.
                // Use compound payload with source bag info                                // Comment.
                BagPackPayload payload;
                strncpy(payload.packCode, pack.code.c_str(), sizeof(payload.packCode) - 1); // Copy code.
                strncpy(payload.sourceBag, bag.name.c_str(), sizeof(payload.sourceBag) - 1); // Copy bag.
                payload.packCode[sizeof(payload.packCode) - 1] = '\0';                      // Terminate.
                payload.sourceBag[sizeof(payload.sourceBag) - 1] = '\0';                    // Terminate.

                ImGui::SetDragDropPayload("PACK_FROM_BAG", &payload, sizeof(BagPackPayload)); // Set payload.
                ImGui::TextColored(ImVec4(0.5f, 0.8f, 1.0f, 1.0f), "Moving: %s", pack.name.c_str()); // Preview.
                ImGui::TextDisabled("From: %s", bag.name.c_str());                          // Preview.
                ImGui::EndDragDropSource();                                                 // End.
            }

            // === DROP TARGET: Accept drops on this pack row ===                           // Comment: Drop target.
            if (ImGui::BeginDragDropTarget()) {                                             // Begin target.
                // Accept from browser                                                      // Comment.
                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("TRAINING_PACK_CODE")) { // Accept.
                    const char* packCode = (const char*)payload->Data;                      // Cast.
                    if (manager) {                                                          // Manager.
                        plugin_->trainingPackMgr->AddPackToBag(packCode, bag.name);         // Add.
                        browserStatus.ShowSuccess("Added to " + bag.name, 2.0f,             // Status.
                            UI::StatusMessage::DisplayMode::TimerWithFade);                 // ...
                    }
                }
                // Accept from another bag                                                  // Comment.
                if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("PACK_FROM_BAG")) { // Accept.
                    const BagPackPayload* data = (const BagPackPayload*)payload->Data;      // Cast.
                    if (manager && std::string(data->sourceBag) != bag.name) {              // Check.
                        plugin_->trainingPackMgr->AddPackToBag(data->packCode, bag.name);   // Add.
                        browserStatus.ShowSuccess("Added to " + bag.name, 2.0f,             // Status.
                            UI::StatusMessage::DisplayMode::TimerWithFade);                 // ...
                    }
                }
                ImGui::EndDragDropTarget();                                                 // End.
            }

            // Context menu for quick remove                                                // Comment: Context menu.
            if (ImGui::BeginPopupContextItem(("PackInBagCtx_" + pack.code).c_str())) {      // Begin popup.
                if (ImGui::MenuItem("Remove from bag")) {                                   // Item.
                    if (manager) {                                                          // Manager.
                        plugin_->trainingPackMgr->RemovePackFromBag(pack.code, bag.name);   // Remove.
                    }
                }
                ImGui::EndPopup();                                                          // End.
            }
        }
    }

    // === DROP TARGET: Remaining empty space ===                                           // Comment: Empty space.
    ImVec2 remaining = ImGui::GetContentRegionAvail();                                      // Get size.
    if (remaining.y > 5.0f) {                                                               // If valid...
        // Create invisible button filling remaining area                                   // Comment.
        ImGui::InvisibleButton(("##BagDropArea_" + bag.name).c_str(), ImVec2(-1, remaining.y)); // Button.

        if (ImGui::BeginDragDropTarget()) {                                                 // Begin target.
            // Accept from browser                                                          // Comment.
            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("TRAINING_PACK_CODE")) { // Accept.
                const char* packCode = (const char*)payload->Data;                          // Cast.
                if (manager) {                                                              // Manager.
                    plugin_->trainingPackMgr->AddPackToBag(packCode, bag.name);             // Add.
                    browserStatus.ShowSuccess("Added to " + bag.name, 2.0f,                 // Status.
                        UI::StatusMessage::DisplayMode::TimerWithFade);                     // ...
                }
            }
            // Accept from another bag                                                      // Comment.
            if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("PACK_FROM_BAG")) { // Accept.
                const BagPackPayload* data = (const BagPackPayload*)payload->Data;          // Cast.
                if (manager && std::string(data->sourceBag) != bag.name) {                  // Check.
                    plugin_->trainingPackMgr->AddPackToBag(data->packCode, bag.name);       // Add.
                    browserStatus.ShowSuccess("Added to " + bag.name, 2.0f,                 // Status.
                        UI::StatusMessage::DisplayMode::TimerWithFade);                     // ...
                }
            }
            ImGui::EndDragDropTarget();                                                     // End.
        }
    }

    ImGui::EndChild();                                                                      // End child.
    ImGui::PopStyleColor();                                                                 // Pop color.
}

void TrainingPackUI::MoveSelectedPackUp(const std::string& bagName) {                       // MoveSelectedPackUp implementation.
    auto it = selectedPackInBag.find(bagName);                                              // Find selection.
    if (it == selectedPackInBag.end()) return;  // No selection                             // Exit.

    std::string packCode = it->second;                                                      // Get code.
    const auto* manager = plugin_->trainingPackMgr;                                         // Manager.
    if (!manager) return;                                                                   // Exit.

    auto packsInBag = manager->GetPacksInBag(bagName);                                      // Get packs.

    // Find pack index                                                                      // Comment.
    int currentIdx = -1;                                                                    // Default.
    for (int i = 0; i < (int)packsInBag.size(); i++) {                                      // Loop.
        if (packsInBag[i].code == packCode) {                                               // Match.
            currentIdx = i;                                                                 // Set idx.
            break;                                                                          // Break.
        }
    }

    if (currentIdx <= 0) return;  // Already at top or not found                            // Exit.

    // Swap with previous pack                                                              // Comment.
    if (plugin_->trainingPackMgr) {                                                         // Check.
        plugin_->trainingPackMgr->SwapPacksInBag(bagName, currentIdx, currentIdx - 1);      // Swap.
    }
}

void TrainingPackUI::MoveSelectedPackDown(const std::string& bagName) {                     // MoveSelectedPackDown implementation.
    auto it = selectedPackInBag.find(bagName);                                              // Find selection.
    if (it == selectedPackInBag.end()) return;  // No selection                             // Exit.

    std::string packCode = it->second;                                                      // Get code.
    const auto* manager = plugin_->trainingPackMgr;                                         // Manager.
    if (!manager) return;                                                                   // Exit.

    auto packsInBag = manager->GetPacksInBag(bagName);                                      // Get packs.

    // Find pack index                                                                      // Comment.
    int currentIdx = -1;                                                                    // Default.
    for (int i = 0; i < (int)packsInBag.size(); i++) {                                      // Loop.
        if (packsInBag[i].code == packCode) {                                               // Match.
            currentIdx = i;                                                                 // Set idx.
            break;                                                                          // Break.
        }
    }

    if (currentIdx < 0 || currentIdx >= (int)packsInBag.size() - 1) return;  // At bottom or not found // Exit.

    // Swap with next pack                                                                  // Comment.
    if (plugin_->trainingPackMgr) {                                                         // Check.
        plugin_->trainingPackMgr->SwapPacksInBag(bagName, currentIdx, currentIdx + 1);      // Swap.
    }
}

bool TrainingPackUI::ValidatePackCode(const char* code) const {                             // ValidatePackCode implementation.
    if (strlen(code) != UI::TrainingPackUI::PACK_CODE_EXPECTED_LENGTH) return false;        // Check length.
    for (int i = 0; i < UI::TrainingPackUI::PACK_CODE_EXPECTED_LENGTH; i++) {               // Loop chars.
        if (i == UI::TrainingPackUI::PACK_CODE_DASH_POSITION_1 || i == UI::TrainingPackUI::PACK_CODE_DASH_POSITION_2 || i == UI::TrainingPackUI::PACK_CODE_DASH_POSITION_3) { // Check dashes.
            if (code[i] != '-') return false;                                               // Return false.
        }
        else {                                                                              // Check alphanumeric.
            if (!isalnum(static_cast<unsigned char>(code[i]))) return false;                // Return false.
        }
    }
    return true;                                                                            // Valid.
}

void TrainingPackUI::ClearCustomPackForm() {                                                // ClearCustomPackForm implementation.
    customPackCode[0] = '\0';                                                               // Clear code.
    customPackName[0] = '\0';                                                               // Clear name.
    customPackCreator[0] = '\0';                                                            // Clear creator.
    customPackDifficulty = 0;                                                               // Reset diff.
    customPackShotCount = 10;                                                               // Reset shots.
    customPackTags[0] = '\0';                                                               // Clear tags.
    customPackNotes[0] = '\0';                                                              // Clear notes.
    customPackVideoUrl[0] = '\0';                                                           // Clear video.
    customPackStatus.Clear();                                                               // Clear status.
}

void TrainingPackUI::RenderCustomPackForm() {                                               // RenderCustomPackForm implementation.
    if (ImGui::CollapsingHeader("Add Custom Pack")) {                                       // Header.
        ImGui::Indent(UI::TrainingPackUI::CUSTOM_PACK_FORM_INDENT);                         // Indent.
        ImGui::Spacing();                                                                   // Spacing.

        customPackStatus.Render(ImGui::GetIO().DeltaTime);                                  // Status.
        if (customPackStatus.IsVisible()) {                                                 // If visible...
            ImGui::Spacing();                                                               // Spacing.
        }

        ImGui::TextUnformatted("Code *");                                                   // Label.
        ImGui::SameLine();                                                                  // Inline.
        ImGui::TextColored(UI::TrainingPackUI::DISABLED_INFO_TEXT_COLOR, "(XXXX-XXXX-XXXX-XXXX)"); // Hint.
        ImGui::SetNextItemWidth(UI::TrainingPackUI::CUSTOM_PACK_CODE_INPUT_WIDTH);          // Width.
        if (ImGui::InputText("##customcode", customPackCode, IM_ARRAYSIZE(customPackCode))) { // Input.
            std::string raw;
            for (int i = 0; customPackCode[i]; i++) {                                       // Loop.
                char c = customPackCode[i];                                                 // Char.
                if (isalnum(static_cast<unsigned char>(c))) {                               // Alphanum.
                    raw += static_cast<char>(toupper(static_cast<unsigned char>(c)));       // Upper.
                }
            }
            if (raw.length() > UI::TrainingPackUI::PACK_CODE_RAW_MAX_LENGTH) raw = raw.substr(0, UI::TrainingPackUI::PACK_CODE_RAW_MAX_LENGTH); // Limit.
            std::string formatted;
            for (size_t i = 0; i < raw.length(); i++) {                                     // Loop.
                if (i > 0 && i % 4 == 0) formatted += '-';                                  // Add dash.
                formatted += raw[i];                                                        // Add char.
            }
            strncpy_s(customPackCode, formatted.c_str(), sizeof(customPackCode) - 1);       // Copy back.
        }

        ImGui::TextUnformatted("Name *");                                                   // Label.
        ImGui::SetNextItemWidth(UI::TrainingPackUI::CUSTOM_PACK_NAME_INPUT_WIDTH);          // Width.
        ImGui::InputText("##customname", customPackName, IM_ARRAYSIZE(customPackName));     // Input.

        ImGui::TextUnformatted("Creator");                                                  // Label.
        ImGui::SetNextItemWidth(UI::TrainingPackUI::CUSTOM_PACK_CREATOR_INPUT_WIDTH);       // Width.
        ImGui::InputText("##customcreator", customPackCreator, IM_ARRAYSIZE(customPackCreator)); // Input.

        ImGui::TextUnformatted("Difficulty");                                               // Label.
        ImGui::SetNextItemWidth(UI::TrainingPackUI::CUSTOM_PACK_DIFFICULTY_DROPDOWN_WIDTH); // Width.
        const char* difficulties[] = {"Unranked", "Bronze", "Silver", "Gold", "Platinum", "Diamond", "Champion", "Grand Champion", "Supersonic Legend"}; // Options.
        ImGui::Combo("##customdifficulty", &customPackDifficulty, difficulties, IM_ARRAYSIZE(difficulties)); // Combo.

        ImGui::TextUnformatted("Shot Count");                                               // Label.
        ImGui::SetNextItemWidth(200);
        ImGui::SliderInt("##customshots", &customPackShotCount, UI::TrainingPackUI::CUSTOM_PACK_SHOTS_MIN, UI::TrainingPackUI::CUSTOM_PACK_SHOTS_MAX); // Slider.

        ImGui::TextUnformatted("Tags");                                                     // Label.
        ImGui::SameLine();                                                                  // Inline.
        ImGui::TextColored(UI::TrainingPackUI::DISABLED_INFO_TEXT_COLOR, "(comma-separated)"); // Hint.
        ImGui::SetNextItemWidth(UI::TrainingPackUI::CUSTOM_PACK_TAGS_INPUT_WIDTH);          // Width.
        ImGui::InputText("##customtags", customPackTags, IM_ARRAYSIZE(customPackTags));     // Input.

        ImGui::TextUnformatted("Notes");                                                    // Label.
        ImGui::InputTextMultiline("##customnotes", customPackNotes, IM_ARRAYSIZE(customPackNotes), ImVec2(UI::TrainingPackUI::CUSTOM_PACK_NOTES_INPUT_WIDTH, UI::TrainingPackUI::CUSTOM_PACK_NOTES_INPUT_HEIGHT)); // Multiline.

        ImGui::TextUnformatted("Video URL");                                                // Label.
        ImGui::SetNextItemWidth(UI::TrainingPackUI::CUSTOM_PACK_VIDEO_URL_INPUT_WIDTH);     // Width.
        ImGui::InputText("##customvideo", customPackVideoUrl, IM_ARRAYSIZE(customPackVideoUrl)); // Input.

        ImGui::Spacing();                                                                   // Spacing.

        if (ImGui::Button("Add Pack", ImVec2(UI::TrainingPackUI::CUSTOM_PACK_ADD_BUTTON_WIDTH, UI::TrainingPackUI::CUSTOM_PACK_ADD_BUTTON_HEIGHT))) { // Add Button.
            customPackStatus.Clear();                                                       // Clear status.
            if (strlen(customPackCode) == 0) {                                              // Check code.
                customPackStatus.ShowError("Pack code is required");                        // Error.
            }
            else if (!ValidatePackCode(customPackCode)) {                                   // Validate.
                customPackStatus.ShowError("Invalid code format. Expected: XXXX-XXXX-XXXX-XXXX"); // Error.
            }
            else if (strlen(customPackName) == 0) {                                         // Check name.
                customPackStatus.ShowError("Pack name is required");                        // Error.
            }
            else {                                                                          // Valid.
                TrainingEntry pack;
                pack.code = customPackCode;
                pack.name = customPackName;
                pack.creator = strlen(customPackCreator) > 0 ? customPackCreator : "Unknown"; // Set creator.
                const char* difficultyNames[] = {"Unranked", "Bronze", "Silver", "Gold", "Platinum", "Diamond", "Champion", "Grand Champion", "Supersonic Legend"}; // Options.
                pack.difficulty = difficultyNames[customPackDifficulty];                    // Set diff.
                pack.shotCount = customPackShotCount;
                if (strlen(customPackTags) > 0) {                                           // Parse tags.
                    std::string tagsStr = customPackTags;
                    size_t start = 0;
                    size_t end = tagsStr.find(',');                                         // End.
                    while (end != std::string::npos) {                                      // Loop.
                        std::string tag = tagsStr.substr(start, end - start);
                        size_t first = tag.find_first_not_of(" \t");                        // Trim.
                        size_t last = tag.find_last_not_of(" \t");                          // Trim.
                        if (first != std::string::npos) {                                   // Valid.
                            pack.tags.push_back(tag.substr(first, last - first + 1));       // Add.
                        }
                        start = end + 1;
                        end = tagsStr.find(',', start);                                     // Find next.
                    }
                    std::string tag = tagsStr.substr(start);
                    size_t first = tag.find_first_not_of(" \t");                            // Trim.
                    size_t last = tag.find_last_not_of(" \t");                              // Trim.
                    if (first != std::string::npos) {                                       // Valid.
                        pack.tags.push_back(tag.substr(first, last - first + 1));           // Add.
                    }
                }
                pack.staffComments = customPackNotes;
                pack.videoUrl = customPackVideoUrl;
                pack.source = "custom";
                pack.isModified = false;
                if (plugin_->trainingPackMgr) {                                             // Check manager.
                    if (plugin_->trainingPackMgr->AddCustomPack(pack)) {                    // Add.
                        customPackStatus.ShowSuccess("Pack added successfully!");           // Success.
                        ClearCustomPackForm();                                              // Clear.
                        LOG("SuiteSpot: Added custom pack: " + pack.name);                  // Log.
                    } else {                                                                // Fail.
                        customPackStatus.ShowError("Pack with this code already exists");     // Error.
                    }
                } else {                                                                    // Error.
                    customPackStatus.ShowError("Pack manager not initialized");             // Error.
                }
            }
        }
        ImGui::SameLine();                                                                  // Inline.
        if (ImGui::Button("Clear", ImVec2(UI::TrainingPackUI::CUSTOM_PACK_CLEAR_BUTTON_WIDTH, UI::TrainingPackUI::CUSTOM_PACK_CLEAR_BUTTON_HEIGHT))) { // Clear Button.
            ClearCustomPackForm();                                                          // Clear.
        }
        ImGui::Spacing();                                                                   // Spacing.
        ImGui::TextColored(UI::TrainingPackUI::DISABLED_INFO_TEXT_COLOR, "* Required fields"); // Hint.
        ImGui::Unindent(UI::TrainingPackUI::CUSTOM_PACK_FORM_INDENT);                       // Unindent.
        ImGui::Spacing();                                                                   // Spacing.
    }
}

void TrainingPackUI::CalculateOptimalColumnWidths() {                                       // CalculateOptimalColumnWidths implementation.
    // Dynamic proportional widths based on full window content width                       // Comment: Logic.
    // Use GetWindowContentRegionWidth() instead of GetContentRegionAvail().x               // Comment: Detail.
    // to get the full width regardless of cursor position                                  // Comment: Detail.
    float availWidth = ImGui::GetWindowContentRegionWidth();                                // Get width.

    // Column proportions: Name (45%), Difficulty (25%), Shots (10%), Likes (10%), Plays (10%) // Comment: Ratios.
    columnWidths.resize(5);                                                                 // Resize.
    columnWidths[0] = availWidth * 0.45f;  // Name                                          // Set.
    columnWidths[1] = availWidth * 0.25f;  // Difficulty                                    // Set.
    columnWidths[2] = availWidth * 0.10f;  // Shots                                         // Set.
    columnWidths[3] = availWidth * 0.10f;  // Likes                                         // Set.
    columnWidths[4] = availWidth * 0.10f;  // Plays                                         // Set.

    // Apply minimum widths to ensure readability                                           // Comment: Min widths.
    if (columnWidths[0] < 150.0f) columnWidths[0] = 150.0f;                                 // Clamp.
    if (columnWidths[1] < 100.0f) columnWidths[1] = 100.0f;                                 // Clamp.
    if (columnWidths[2] < 60.0f) columnWidths[2] = 60.0f;                                   // Clamp.
    if (columnWidths[3] < 60.0f) columnWidths[3] = 60.0f;                                   // Clamp.
    if (columnWidths[4] < 60.0f) columnWidths[4] = 60.0f;                                   // Clamp.
}

std::string TrainingPackUI::GetMenuName() {                                                 // GetMenuName.
    return "suitespot_browser";                                                             // Return name.
}

std::string TrainingPackUI::GetMenuTitle() {                                                // GetMenuTitle.
    return "SuiteSpot Training Browser";                                                    // Return title.
}

void TrainingPackUI::SetImGuiContext(uintptr_t ctx) {                                       // SetImGuiContext.
    ImGui::SetCurrentContext(reinterpret_cast<ImGuiContext*>(ctx));                         // Set context.
}

bool TrainingPackUI::ShouldBlockInput() {
    if (!isWindowOpen_) {                                                                   // Check closed.
        return false;  // Window closed  no blocking                                       // Return false.
    }

    // ============================================================================         // Comment: Header.
    // INPUT BLOCKING STRATEGY                                                              // Comment: Title.
    // ============================================================================         // Comment: Header.
    //                                                                                      // Spacer.
    // The default PluginWindowBase::ShouldBlockInput() blocks ALL application              // Comment: Context.
    // input whenever ImGui wants mouse or keyboard input. This is too aggressive           // Comment: Context.
    // and prevents multi-window interactions like drag-and-drop.                           // Comment: Context.
    //                                                                                      // Spacer.
    // Our selective approach:                                                              // Comment: Strategy.
    // 1. Allow drag-and-drop between browser and bag manager (modal popups)                // Comment: Point 1.
    // 2. Block only when user is actively typing in text fields                            // Comment: Point 2.
    // 3. Allow normal mouse interactions (clicking, hovering, scrolling)                   // Comment: Point 3.
    //                                                                                      // Spacer.
    // This enables the drag-and-drop UX while maintaining text input safety.               // Comment: Benefit.
    // Based on: docs/Examples/ManagingMultipleWindows.md:163-180                           // Comment: Reference.
    // ============================================================================         // Comment: Header.

    ImGuiIO& io = ImGui::GetIO();                                                           // Get IO.

    // Block when actively typing in text fields (search box, custom pack form)             // Comment: Logic.
    // This prevents game commands from firing while typing                                 // Comment: Reason.
    if (io.WantTextInput && ImGui::IsAnyItemActive()) {                                     // Check typing.
        return true;                                                                        // Block.
    }

    // Allow normal mouse interaction without blocking game input                           // Comment: Logic.
    // This includes drag-and-drop operations between browser and bag manager modal         // Comment: Logic.
    // Note: We intentionally DON'T block for popups/modals because the Bag Manager modal   // Comment: Logic.
    // needs to allow drag operations from the parent browser window (same ImGui context)   // Comment: Logic.
    return false;                                                                           // Allow.
}

bool TrainingPackUI::IsActiveOverlay() {                                                    // IsActiveOverlay.
    return isWindowOpen_;                                                                   // Return state.
}

void TrainingPackUI::OnOpen() {                                                             // OnOpen.
    isWindowOpen_ = true;                                                                   // Set true.
    needsFocusOnNextRender_ = true;  // Bring window to front on next render                // Request focus.
}

void TrainingPackUI::OnClose() {                                                            // OnClose.
    isWindowOpen_ = false;                                                                  // Set false.
}

bool TrainingPackUI::IsOpen() {                                                             // IsOpen.
    return isWindowOpen_;                                                                   // Return state.
}

void TrainingPackUI::SetOpen(bool open) {                                                   // SetOpen.
    isWindowOpen_ = open;                                                                   // Set state.
}

void TrainingPackUI::LoadPackImmediately(const std::string& packCode) {                     // LoadPackImmediately.
    if (packCode.empty() || !plugin_) return;                                               // Check valid.

    // Increment usage stats                                                                // Comment: Stats.
    if (plugin_->usageTracker) {                                                            // If tracker...
        plugin_->usageTracker->IncrementLoadCount(packCode);                                // Inc count.
    }

    // Find pack name for logging                                                           // Comment: Logging.
    std::string packName = packCode;                                                        // Default.
    const auto* manager = plugin_->trainingPackMgr;                                         // Manager.
    if (manager) {                                                                          // If manager...
        for (const auto& pack : manager->GetPacks()) {                                      // Loop packs.
            if (pack.code == packCode) {                                                    // Match.
                packName = pack.name;                                                       // Set name.
                break;                                                                          // Break.
            }
        }
    }

    // Execute load immediately (0 delay)                                                   // Comment: Execution.
    SuiteSpot* p = plugin_;                                                                 // Alias.
    std::string code = packCode;                                                            // Copy.
    p->gameWrapper->SetTimeout([p, code, packName](GameWrapper* gw) {                       // Timeout.
        p->cvarManager->executeCommand("load_training " + code);
        LOG("SuiteSpot: Loading training pack immediately: {}", packName);                  // Log.
    }, 0.0f);                                                                               // Immediate.

    browserStatus.ShowSuccess("Loading: " + packName, 2.0f,
        UI::StatusMessage::DisplayMode::TimerWithFade);
}

// ======================================================================================
// FILE: SuiteSpot.cpp (Partial - UI Methods)
// ======================================================================================

// Render - The main render loop for the plugin's custom window                             // Comment: Method.
// Note: This is separate from RenderSettings (which is the F2 menu)                         // Comment: Context.
void SuiteSpot::Render() {                                                                  // Render implementation.
    if (!imgui_ctx) return;                                                                 // Safety check.
    ImGui::SetCurrentContext(reinterpret_cast<ImGuiContext*>(imgui_ctx));                   // Set context.

    // Note: TrainingPackUI is a PluginWindow registered with BakkesMod,                    // Comment.
    // so it's rendered automatically by the framework. No need to call it here.            // Comment.
}

std::string SuiteSpot::GetMenuName() {                                                      // GetMenuName.
    return "suitespot_browser";                                                             // Return identifier.
}

std::string SuiteSpot::GetMenuTitle() {                                                     // GetMenuTitle.
    return "SuiteSpot Training Browser";                                                    // Return display title.
}

void SuiteSpot::SetImGuiContext(uintptr_t ctx) {                                            // SetImGuiContext.
    if (ctx) {                                                                              // Check valid.
        imgui_ctx = ctx;                                                                    // Store.
        ImGui::SetCurrentContext(reinterpret_cast<ImGuiContext*>(ctx));                     // Apply.
    }
}

bool SuiteSpot::ShouldBlockInput() {                                                        // ShouldBlockInput.
    if (!isBrowserOpen) {                                                                   // If closed...
        return false;  // Browser closed  no blocking                                      // Allow input.
    }

    // Selective input blocking - consistent with TrainingPackUI                            // Comment: Logic.
    ImGuiIO& io = ImGui::GetIO();                                                           // Get IO.

    // Block when actively typing in text fields (settings UI)                              // Comment: Logic.
    if (io.WantTextInput && ImGui::IsAnyItemActive()) {                                     // Check typing.
        return true;                                                                        // Block.
    }

    // Allow normal mouse interaction without blocking game input                           // Comment: Logic.
    return false;                                                                           // Allow input.
}

bool SuiteSpot::IsActiveOverlay() {                                                         // IsActiveOverlay.
    return isBrowserOpen;                                                                   // Return state.
}

void SuiteSpot::OnOpen() {                                                                  // OnOpen.
    LOG("SuiteSpot: OnOpen called");                                                        // Log.
    isBrowserOpen = true;                                                                   // Set open.
    if (trainingPackUI) {                                                                   // If UI exists...
        trainingPackUI->SetOpen(true);                                                      // Open UI.
    }
}

void SuiteSpot::OnClose() {                                                                 // OnClose.
    LOG("SuiteSpot: OnClose called (Ignoring state change to keep browser open)");          // Log.
    // isBrowserOpen = false; // Disabled to prevent F2 from closing browser                // Comment: Disabled logic.
    // if (trainingPackUI) {                                                                // Comment.
    //    trainingPackUI->SetOpen(false);                                                   // Comment.
    // }                                                                                    // Comment.
}

// ======================================================================================
// FILE: Source.cpp
// ======================================================================================
#include "pch.h"                                                                            // Header.
#include "SuiteSpot.h"                                                                      // Header.
#include "SettingsUI.h"                                                                     // Header.
#include "TrainingPackUI.h"                                                                 // Header.

// #detailed comments: RenderSettings                                                       // Comment: Docs.
// Purpose: Build the Settings UI using ImGui. This method is called on                     // Comment.
// the UI thread and must complete quickly  avoid heavy computation                        // Comment.
// or blocking calls here. Instead, schedule background work with                           // Comment.
// gameWrapper->SetTimeout if needed.                                                       // Comment.
//                                                                                          // Spacer.
// UI & state invariants:                                                                   // Comment.
//  - Any changes to cvars must keep the CVar<->member variable sync                        // Comment.
//    consistent. The code uses cvarManager to persist values and also                      // Comment.
//    updates plugin members; changing the order of writes may create                       // Comment.
//    transient inconsistencies visible to users.                                           // Comment.
//  - Many UI controls guard against empty lists (e.g., RLTraining) and                     // Comment.
//    clamp indices to valid ranges to prevent out-of-bounds access.                        // Comment.
//                                                                                          // Spacer.
// DO NOT CHANGE: Rendering flow, label strings, and cvar names are                         // Comment.
// relied upon by external automation and saved settings; altering them                     // Comment.
// will change user-visible state persistence and CLI integrations.                         // Comment.
void SuiteSpot::RenderSettings() {                                                          // RenderSettings implementation.
    isRenderingSettings = true;                                                             // Set flag.
    // 1. Render the main settings UI                                                       // Comment.
    if (settingsUI) {                                                                       // If UI exists...
        settingsUI->RenderMainSettingsWindow();                                             // Render it.
    }
    
    // 2. Render browser if open (Since RegisterDrawable is blocked)                        // Comment.
    if (isBrowserOpen && trainingPackUI) {                                                  // If browser open...
        trainingPackUI->Render();                                                           // Render browser.
    }
    isRenderingSettings = false;                                                            // Reset flag.
}

// ======================================================================================
// FILE: IMGUI/imgui_additions.h
// ======================================================================================
#pragma once                                                                                // Header guard.
#include <string>                                                                           // Include string.
#include <vector>                                                                           // Include vector.
#include "imgui.h"                                                                          // Main ImGui header.
#include "imgui_internal.h"                                                                 // Internal ImGui header.

namespace ImGui                                                                             // Extend ImGui namespace.
{                                                                                           // Begin.
	static auto vector_getter = [](void* vec, int idx, const char** out_text)               // Lambda: Bridge between std::vector and ImGui's C-style callbacks.
	{                                                                                       // Begin lambda.
		auto& vector = *static_cast<std::vector<std::string>*>(vec);                        // Cast void* back to vector reference.
		if (idx < 0 || idx >= static_cast<int>(vector.size())) { return false; }            // Range check.
		*out_text = vector.at(idx).c_str();                                                 // Set output text pointer.
		return true;                                                                        // Return success.
	};                                                                                      // End lambda.
	bool Combo(const char* label, int* currIndex, std::vector<std::string>& values);        // Declaration: Combo box for std::vector<string>.
	bool ListBox(const char* label, int* currIndex, std::vector<std::string>& values);      // Declaration: List box for std::vector<string>.
}                                                                                           // End namespace.

// ======================================================================================
// FILE: IMGUI/imgui_additions.cpp
// ======================================================================================
#include "pch.h"                                                                            // Precompiled header.
#include "imgui_additions.h"                                                                // Include header.

namespace ImGui {                                                                           // Extend ImGui namespace.
	bool Combo(const char* label, int* currIndex, std::vector<std::string>& values)         // Define Combo wrapper.
	{                                                                                       // Begin.
		if (values.empty()) { return false; }                                               // Guard: exit if no items.
		return Combo(label, currIndex, vector_getter,                                       // Call standard ImGui::Combo with custom getter.
			static_cast<void*>(&values), values.size());                                    // Pass vector as data and its size.
	}                                                                                       // End.

	bool ListBox(const char* label, int* currIndex, std::vector<std::string>& values)       // Define ListBox wrapper.
	{                                                                                       // Begin.
		if (values.empty()) { return false; }                                               // Guard: exit if no items.
		return ListBox(label, currIndex, vector_getter,                                     // Call standard ImGui::ListBox with custom getter.
			static_cast<void*>(&values), values.size());                                    // Pass vector as data and its size.
	}                                                                                       // End.
}                                                                                           // End namespace.

// ======================================================================================
// FILE: MapList.h
// ======================================================================================
#pragma once                                                                                // Header guard.
#include <string>                                                                           // Include string.
#include <vector>                                                                           // Include vector.
#include <set>                                                                              // Include set.

// Freeplay maps                                                                            // Comment: Section.
struct MapEntry {                                                                           // Data structure for official maps.
    std::string code;                                                                       // Internal map identifier (e.g., "Stadium_P").
    std::string name;                                                                       // User-friendly display name (e.g., "DFH Stadium").
};                                                                                          // End struct.
extern std::vector<MapEntry> RLMaps;                                                        // Global list of available Freeplay maps.

// Training bag categories for organized pack rotation                                      // Comment: Section.
struct TrainingBag {                                                                        // Data structure for pack collections.
    std::string name;                       // Internal name: "Defense", "Offense", etc.    // Unique identifier.
    std::string displayName;                // Display name with icon: " Defense"         // UI label.
    std::string icon;                       // Icon only: ""                              // Icon character.
    std::vector<std::string> autoTags;      // Tags that auto-add packs to this bag         // Rules for automation.
    bool enabled = true;                    // Include in rotation                          // Toggle state.
    int priority = 0;                       // Rotation order (lower = first)               // Sequence weight.
    bool isUserCreated = false;             // true for custom bags                         // Origin flag.
    float color[4] = {1.0f, 1.0f, 1.0f, 1.0f};  // Badge color (RGBA)                       // UI color setting.
};                                                                                          // End struct.

// Training packs                                                                           // Comment: Section.
struct TrainingEntry {                                                                      // Data structure for custom training.
    std::string code;                                                                       // The 16-character hex code.
    std::string name;                                                                       // Pack name.

    // Pack metadata                                                                        // Comment: Metadata fields.
    std::string creator;            // Creator's display name                               // Creator name.
    std::string creatorSlug;        // Creator's username (for linking)                     // Link slug.
    std::string difficulty;         // Bronze, Gold, Platinum, Diamond, Champion, Supersonic Legend // Rank.
    std::vector<std::string> tags;  // Array of tags                                        // Category tags.
    int shotCount = 0;              // Number of shots                                      // Count.
    std::string staffComments;      // Staff description                                    // Editorial note.
    std::string notes;              // Creator's notes                                      // Description.
    std::string videoUrl;           // Optional YouTube link                                // Preview URL.
    int likes = 0;                  // Engagement metric                                    // Likes count.
    int plays = 0;                  // Engagement metric                                    // Plays count.
    int status = 1;                 // Pack status (1 = active)                             // Health status.

    // Unified system fields                                                                // Comment: Internal fields.
    std::string source = "prejump"; // "prejump" or "custom"                                // Data source.
    std::set<std::string> bagCategories;  // Categorized bag membership (e.g., "Defense", "Offense") // Grouping.
    std::map<std::string, int> orderInBag;  // Position within each bag (0 = first)         // Sorting.
    bool isModified = false;        // Track if user edited a scraped pack                  // Dirty flag.
};                                                                                          // End struct.
extern std::vector<TrainingEntry> RLTraining;                                               // Global list of training packs.

// Workshop maps                                                                            // Comment: Section.
struct WorkshopEntry {                                                                      // Data structure for modded maps.
    std::string filePath;                                                                   // Disk path to .upk/.udk file.
    std::string name;                                                                       // Display name.
};                                                                                          // End struct.
extern std::vector<WorkshopEntry> RLWorkshop;                                               // Global list of workshop maps.


// ====================================================================================== 
// FILE: MapList.cpp
// ====================================================================================== 
// #detailed comments: MapList data                                                         // Comment: Docs. 
// Purpose: Static lists of maps/training/workshop entries used by the                      // Comment. 
// UI and loading logic. These containers are intentionally defined in                      // Comment. 
// a dedicated translation unit to keep the dataset separate from                           // Comment. 
// plugin logic. Treat these vectors as read-mostly...                                      // Comment. 
#include "pch.h"                                                                            // Header. 
#include "MapList.h"                                                                        // Header. 
#include "SuiteSpot.h"                                                                      // Header. 

std::vector<MapEntry> RLMaps = {                                                            // Initialization of official map list. 
    { "Underwater_P","AquaDome" },                                                          // Data entry. 
    { "Underwater_GRS_P","AquaDome (Salty Shallows)" },                                     // Data entry. 
    { "Park_P","Beckwith Park" },                                                           // Data entry. 
    { "Park_Night_P","Beckwith Park (Midnight)" },                                          // Data entry. 
    { "Park_Snowy_P","Beckwith Park (Snowy)" },                                             // Data entry. 
    { "Park_Rainy_P","Beckwith Park (Stormy)" },                                            // Data entry. 
    { "mall_day_p","Boostfield Mall" },                                                     // Data entry. 
    { "cs_p","Champions Field" },                                                           // Data entry. 
    { "cs_day_p","Champions Field (Day)" },                                                 // Data entry. 
    { "outlaw_p","Deadeye Canyon" },                                                        // Data entry. 
    { "Outlaw_Oasis_P","Deadeye Canyon (Oasis)" },                                          // Data entry. 
    { "Stadium_P","DFH Stadium" },                                                          // Data entry. 
    { "Stadium_Race_Day_p","DFH Stadium (Circuit)" },                                       // Data entry. 
    { "stadium_day_p","DFH Stadium (Day)" },                                                // Data entry. 
    { "Stadium_Winter_P","DFH Stadium (Snowy)" },                                           // Data entry. 
    { "Stadium_Foggy_P","DFH Stadium (Stormy)" },                                           // Data entry. 
    { "STADIUM_10A_P","DFH Stadium (10th Anniversary)" },                                   // Data entry. 
    { "woods_p","Drift Woods" },                                                            // Data entry. 
    { "Woods_Night_P","Drift Woods (Night)" },                                              // Data entry. 
    { "FF_Dusk_P","Estadio Vida" },                                                         // Data entry. 
    { "farm_p","Farmstead" },                                                               // Data entry. 
    { "Farm_Night_P","Farmstead (Night)" },                                                 // Data entry. 
    { "Farm_HW_P","Farmstead (Spooky)" },                                                   // Data entry. 
    { "Farm_GRS_P","Farmstead (Pitched)" },                                                 // Data entry. 
    { "CHN_Stadium_P","Forbidden Temple" },                                                 // Data entry. 
    { "CHN_Stadium_Day_P","Forbidden Temple (Day)" },                                       // Data entry. 
    { "FNI_Stadium_P","Forbidden Temple (Fire & Ice)" },                                    // Data entry. 
    { "UF_Day_P","Futura Garden" },                                                         // Data entry. 
    { "EuroStadium_P","Mannfield" },                                                        // Data entry. 
    { "EuroStadium_Dusk_P","Mannfield (Dusk)" },                                            // Data entry. 
    { "EuroStadium_Night_P","Mannfield (Night)" },                                          // Data entry. 
    { "eurostadium_snownight_p","Mannfield (Snowy)" },                                      // Data entry. 
    { "EuroStadium_Rainy_P","Mannfield (Stormy)" },                                         // Data entry. 
    { "NeoTokyo_Standard_P","Neo Tokyo" },                                                  // Data entry. 
    { "NeoTokyo_Toon_p","Neo Tokyo (Comic)" },                                              // Data entry. 
    { "NeoTokyo_Hax_P","Neo Tokyo (Hacked)" },                                              // Data entry. 
    { "NeoTokyo_Arcade_P","Neo Tokyo (Arcade)" },                                           // Data entry. 
    { "music_p","Neon Fields" },                                                            // Data entry. 
    { "beach_P","Salty Shores" },                                                           // Data entry. 
    { "beach_night_p","Salty Shores (Night)" },                                             // Data entry. 
    { "Beach_Night_GRS_P","Salty Shores (Salty Fest)" },                                    // Data entry. 
    { "street_p","Sovereign Heights" },                                                     // Data entry. 
    { "arc_standard_p","Starbase ARC" },                                                    // Data entry. 
    { "ARC_Darc_P","Starbase ARC (Aftermath)" },                                            // Data entry. 
    { "TrainStation_P","Urban Central" },                                                   // Data entry. 
    { "TrainStation_Dawn_P","Urban Central (Dawn)" },                                       // Data entry. 
    { "TrainStation_Night_P","Urban Central (Night)" },                                     // Data entry. 
    { "UtopiaStadium_P","Utopia Coliseum" },                                                // Data entry. 
    { "UtopiaStadium_Dusk_P","Utopia Coliseum (Dusk)" },                                    // Data entry. 
    { "UtopiaStadium_Lux_P","Utopia Coliseum (Gilded)" },                                   // Data entry. 
    { "UtopiaStadium_Snow_P","Utopia Coliseum (Snowy)" },                                   // Data entry. 
    { "wasteland_s_p","Wasteland" },                                                        // Data entry. 
    { "wasteland_Night_S_P","Wasteland (Night)" },                                          // Data entry. 
    { "Wasteland_GRS_P","Wasteland (Pitched)" },                                            // Data entry. 
    { "ARC_P","ARCtagon" },                                                                 // Data entry. 
    { "Wasteland_P","Badlands" },                                                           // Data entry. 
    { "Wasteland_Night_P","Badlands (Night)" },                                             // Data entry. 
    { "NeoTokyo_P","Tokyo Underpass" },                                                     // Data entry. 
    { "throwbackstadium_P","Throwback Stadium" },                                           // Data entry. 
    { "Labs_PillarHeat_P","Barricade" },                                                    // Data entry. 
    { "Labs_Basin_P","Basin" },                                                             // Data entry. 
    { "Labs_PillarWings_P","Colossus" },                                                    // Data entry. 
    { "Labs_Corridor_P","Corridor" },                                                       // Data entry. 
    { "Labs_Cosmic_V4_P","Cosmic" },                                                        // Data entry. 
    { "Labs_DoubleGoal_V2_P","Double Goal" },                                               // Data entry. 
    { "Labs_Galleon_P","Galleon" },                                                         // Data entry. 
    { "Labs_Galleon_Mast_P","Galleon Retro" },                                              // Data entry. 
    { "Labs_PillarGlass_P","Hourglass" },                                                   // Data entry. 
    { "Labs_Holyfield_P","Loophole" },                                                      // Data entry. 
    { "Labs_Holyfield_Space_P","Force Field" },                                             // Data entry. 
    { "Labs_Octagon_02_P","Octagon" },                                                      // Data entry. 
    { "Labs_CirclePillars_P","Pillars" },                                                   // Data entry. 
    { "Labs_Underpass_P","Underpass" },                                                     // Data entry. 
    { "Labs_Utopia_P","Utopia Retro" },                                                     // Data entry. 
};                                                                                          // End vector. 

std::vector<TrainingEntry> RLTraining = {                                                   // Dynamic training list placeholder. 
   //{"C8C8-78AF-66F2-6958", "WallReadss"}                                                // (Empty initially, populated by cache). 
};

std::vector<WorkshopEntry> RLWorkshop = {                                                   // Dynamic workshop list placeholder. 
    //{ "C:\\Path\\to\\map.upk, mapname" }                                                 // (Empty initially, populated by discovery). 
};


// ======================================================================================
// FILE: DefaultPacks.h
// ======================================================================================
#pragma once                                                                                // Header guard.
#include <string>                                                                           // Include string.
#include <vector>                                                                           // Include vector.

struct DefaultPackData {                                                                    // Data structure for hardcoded pack defaults.
    std::string code;                                                                       // 16-char hex code.
    std::string name;                                                                       // Display name.
    int shotCount;                                                                          // Number of shots.
    std::string description;                                                                // Description text.
};                                                                                          // End struct.

namespace DefaultPacks {                                                                    // Namespace for default data.
    inline const std::vector<DefaultPackData> FLICKS_PICKS = {                              // Constant vector of curated packs ("Quick Picks").
        {                                                                                   // Pack 1.
            "CE79-F64D-344F-5F1E",                                                          // Code.
            "Aerial Shots - Redirect",                                                      // Name.
            44,                                                                             // Shots.
            "This pack focuses on redirecting aerial shots, an essential offensive move to have in your arsenal. The 44 shots are designed to challenge even the most experienced players." // Desc.
        },                                                                                  // End Pack 1.
        {                                                                                   // Pack 2.
            "FA24-B2B7-2E8E-193B",                                                          // Code.
            "Ultimate Warm-Up",                                                             // Name.
            50,                                                                             // Shots.
            "Complete warm-up routine for all skill levels. Covers a wide range of mechanics to get you ready for ranked play." // Desc.
        },                                                                                  // End Pack 2.
        {                                                                                   // Pack 3.
            "D7F8-FD53-98D1-DAFE",                                                          // Code.
            "Backboard Therapy",                                                            // Name.
            40,                                                                             // Shots.
            "This training pack is designed to help players master their aerials off of the backboard. Perfect for players looking to improve their offensive capabilities." // Desc.
        },                                                                                  // End Pack 3.
        {                                                                                   // Pack 4.
            "6EB1-79B2-33B8-681C",                                                          // Code.
            "Ground Shots",                                                                 // Name.
            50,                                                                             // Shots.
            "This training pack contains 50 shots that cover just about any possible ground shot you could see in a game. It includes a variety of angles, distances, and speeds." // Desc.
        },                                                                                  // End Pack 4.
        {                                                                                   // Pack 5.
            "5A65-4073-F310-5495",                                                          // Code.
            "Wall to Air Dribble",                                                          // Name.
            3,                                                                              // Shots.
            "This training pack is designed to help you improve your wall to air dribbling skills. The shots are set up to roll perfectly up the wall, allowing you to practice your setup and control." // Desc.
        },                                                                                  // End Pack 5.
        {                                                                                   // Pack 6.
            "A503-264C-A7EB-D282",                                                          // Code.
            "Musty's Speed Flip Kickoff",                                                   // Name.
            3,                                                                              // Shots.
            "This pack is designed to help you practice the speedflip kickoff, a technique that allows you to reach supersonic speed quickly off the kickoff." // Desc.
        },                                                                                  // End Pack 6.
        {                                                                                   // Pack 7.
            "CEB6-7AF0-9A2E-B92D",                                                          // Code.
            "Flip Reset",                                                                   // Name.
            10,                                                                             // Shots.
            "This training pack includes a variety of shots to help you practice and master the flip reset mechanic. The shots are designed to be realistic and game-like." // Desc.
        },                                                                                  // End Pack 7.
        {                                                                                   // Pack 8.
            "6CF3-4C0B-32B4-1AC7",                                                          // Code.
            "Power Shots",                                                                  // Name.
            20,                                                                             // Shots.
            "This pack is designed to help players improve their power and accuracy when shooting. It includes 20 shots that vary in distance and angle." // Desc.
        },                                                                                  // End Pack 8.
        {                                                                                   // Pack 9.
            "2E23-ABD5-20C6-DBD4",                                                          // Code.
            "Saves",                                                                        // Name.
            50,                                                                             // Shots.
            "This training pack includes 50 different saves that cover a wide range of situations. From simple shots to difficult redirects, this pack will help you improve your reaction time." // Desc.
        },                                                                                  // End Pack 9.
        {                                                                                   // Pack 10.
            "CAFC-FB3E-3C0F-B8F1",                                                          // Code.
            "Double Shot Playground",                                                       // Name.
            50,                                                                             // Shots.
            "This pack is designed for advanced players who are looking to perfect their aerial skills and double tap shots. The shots in this pack involve using the backboard as a self-setup tool." // Desc.
        }                                                                                   // End Pack 10.
    };                                                                                      // End vector.
}                                                                                           // End namespace.

// ======================================================================================
// FILE: IMGUI/imgui_stdlib.h
// ======================================================================================
#pragma once                                                                                // Header guard.
#include <string>                                                                           // Include std::string.

namespace ImGui                                                                             // Extend ImGui namespace.
{                                                                                           // Begin.
    // ImGui::InputText() with std::string                                                  // Comment.
    // Because text input needs dynamic resizing, we need to setup a callback to grow the capacity // Comment.
    IMGUI_API bool  InputText(const char* label, std::string* str, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL); // std::string wrapper.
    IMGUI_API bool  InputTextMultiline(const char* label, std::string* str, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL); // std::string wrapper.
    IMGUI_API bool  InputTextWithHint(const char* label, const char* hint, std::string* str, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = NULL, void* user_data = NULL); // std::string wrapper.
}                                                                                           // End namespace.

// ======================================================================================
// FILE: IMGUI/imgui_stdlib.cpp
// ======================================================================================
#include "pch.h"                                                                            // Precompiled header.
#include "imgui.h"                                                                          // ImGui header.
#include "imgui_stdlib.h"                                                                   // stdlib header.

struct InputTextCallback_UserData                                                           // Callback user data struct.
{                                                                                           // Begin.
    std::string*            Str;                                                            // Pointer to string.
    ImGuiInputTextCallback  ChainCallback;                                                  // User callback to chain.
    void*                   ChainCallbackUserData;                                          // User data to chain.
};                                                                                          // End.

static int InputTextCallback(ImGuiInputTextCallbackData* data)                              // Internal callback.
{                                                                                           // Begin.
    InputTextCallback_UserData* user_data = (InputTextCallback_UserData*)data->UserData;    // Cast user data.
    if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)                              // If resize event...
    {                                                                                       // Begin block.
        // Resize string callback                                                           // Comment.
        // If for some reason we refuse the new length (BufTextLen) and/or capacity (BufSize) we need to set them back to what we want. // Comment.
        std::string* str = user_data->Str;                                                  // Get string.
        IM_ASSERT(data->Buf == str->c_str());                                               // Assert buffer match.
        str->resize(data->BufTextLen);                                                      // Resize string.
        data->Buf = (char*)str->c_str();                                                    // Update buffer pointer (in case realloc).
    }                                                                                       // End block.
    else if (user_data->ChainCallback)                                                      // If chain callback...
    {                                                                                       // Begin block.
        // Forward to user callback, if any                                                 // Comment.
        data->UserData = user_data->ChainCallbackUserData;                                  // Restore user data.
        return user_data->ChainCallback(data);                                              // Call user callback.
    }                                                                                       // End block.
    return 0;                                                                               // Return 0.
}                                                                                           // End callback.

bool ImGui::InputText(const char* label, std::string* str, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data) // Wrapper implementation.
{                                                                                           // Begin.
    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);                           // Ensure flag not set manually.
    flags |= ImGuiInputTextFlags_CallbackResize;                                            // Set resize flag.

    InputTextCallback_UserData cb_user_data;                                                // Create data.
    cb_user_data.Str = str;                                                                 // Set string.
    cb_user_data.ChainCallback = callback;                                                  // Set callback.
    cb_user_data.ChainCallbackUserData = user_data;                                         // Set user data.
    return InputText(label, (char*)str->c_str(), str->capacity() + 1, flags, InputTextCallback, &cb_user_data); // Call core function.
}                                                                                           // End.

bool ImGui::InputTextMultiline(const char* label, std::string* str, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data) // Wrapper implementation.
{                                                                                           // Begin.
    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);                           // Ensure flag not set manually.
    flags |= ImGuiInputTextFlags_CallbackResize;                                            // Set resize flag.

    InputTextCallback_UserData cb_user_data;                                                // Create data.
    cb_user_data.Str = str;                                                                 // Set string.
    cb_user_data.ChainCallback = callback;                                                  // Set callback.
    cb_user_data.ChainCallbackUserData = user_data;                                         // Set user data.
    return InputTextMultiline(label, (char*)str->c_str(), str->capacity() + 1, size, flags, InputTextCallback, &cb_user_data); // Call core function.
}                                                                                           // End.

bool ImGui::InputTextWithHint(const char* label, const char* hint, std::string* str, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data) // Wrapper implementation.
{                                                                                           // Begin.
    IM_ASSERT((flags & ImGuiInputTextFlags_CallbackResize) == 0);                           // Ensure flag not set manually.
    flags |= ImGuiInputTextFlags_CallbackResize;                                            // Set resize flag.

    InputTextCallback_UserData cb_user_data;                                                // Create data.
    cb_user_data.Str = str;                                                                 // Set string.
    cb_user_data.ChainCallback = callback;                                                  // Set callback.
    cb_user_data.ChainCallbackUserData = user_data;                                         // Set user data.
    return InputTextWithHint(label, hint, (char*)str->c_str(), str->capacity() + 1, flags, InputTextCallback, &cb_user_data); // Call core function.
}                                                                                           // End.

// ======================================================================================
// FILE: IMGUI/imgui_searchablecombo.h
// ======================================================================================
#pragma once                                                                                // Header guard.
#include "imgui.h"                                                                          // ImGui header.

#include <ctype.h>      // isprint                                                          // CType for character functions.
#include <vector>       // vector<>                                                         // Vector.
#include <string>       // string                                                           // String.
#include <algorithm>    // transform                                                        // Algorithm for transform.

namespace ImGui                                                                             // Extend ImGui namespace.
{                                                                                           // Begin.
    IMGUI_API bool          BeginSearchableCombo(const char* label, const char* preview_value, char* input, int input_size, const char* input_preview_value, ImGuiComboFlags flags = 0); // Custom combo begin.
    IMGUI_API void          EndSearchableCombo();                                           // Custom combo end.
    IMGUI_API bool          SearchableCombo(const char* label, int* current_item, std::vector<std::string> items, const char* default_preview_text, const char* input_preview_value, int popup_max_height_in_items = -1); // Helper wrapper.
} // namespace ImGui                                                                        // End namespace.

// ======================================================================================
// FILE: IMGUI/imgui_searchablecombo.cpp
// ======================================================================================
#include "pch.h"                                                                            // Precompiled header.
#include "imgui_searchablecombo.h"                                                          // Header.
#include "imgui_internal.h"                                                                 // Internal for advanced window/layout access.

static float CalcMaxPopupHeightFromItemCount(int items_count)                               // Helper: Calc height.
{                                                                                           // Begin.
    ImGuiContext& g = *GImGui;                                                              // Context.
    if (items_count <= 0)                                                                   // If invalid count...
        return FLT_MAX;                                                                     // Return max float.
    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2); // Calculate based on style.
}                                                                                           // End.

/* Modified version of BeginCombo from imgui.cpp at line 9172,
 * to include a input field to be able to filter the combo values. */                       // Comment: Origin.
bool ImGui::BeginSearchableCombo(const char* label, const char* preview_value, char* input, int input_size, const char* input_preview_value, ImGuiComboFlags flags) // Implementation.
{                                                                                           // Begin.
    // Always consume the SetNextWindowSizeConstraint() call in our early return paths      // Comment.
    ImGuiContext& g = *GImGui;                                                              // Context.
    bool has_window_size_constraint = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint) != 0; // Check constraint.
    g.NextWindowData.Flags &= ~ImGuiNextWindowDataFlags_HasSizeConstraint;                  // Clear flag.

    ImGuiWindow* window = GetCurrentWindow();                                               // Get window.
    if (window->SkipItems)                                                                  // If skip...
        return false;                                                                       // Return false.

    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

    const ImGuiStyle& style = g.Style;                                                      // Style alias.
    const ImGuiID id = window->GetID(label);                                                // Get ID.

    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight(); // Calc arrow size.
    const ImVec2 label_size = CalcTextSize(label, NULL, true);                              // Calc label size.
    const float expected_w = CalcItemWidth();                                               // Calc expected width.
    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : expected_w;          // Determine width.
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f)); // Bounding box.
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f)); // Total BB.

    bool hovered, held;                                                                     // State vars.
    bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);                           // Button behavior.
    bool popup_open = IsPopupOpen(id);                                                      // Check open.

    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg); // Frame color.
    const float value_x2 = ImMax(frame_bb.Min.x, frame_bb.Max.x - arrow_size);              // Content end X.

    if (popup_open || (pressed || g.NavActivateId == id))                                   // If interacting...
    {                                                                                       // Begin block.
        ImGuiID activeId = g.ActiveId;                                                      // Backup active ID.
        if (popup_open)                                                                     // If open...
            g.ActiveId = id;                                                                // Set active.
        else                                                                                // Else...
            g.NavInputId = id;                                                              // Set nav input.
        InputTextEx(label, input_preview_value, input, input_size, frame_bb.Max - frame_bb.Min, ImGuiInputTextFlags_NoUndoRedo); // Draw input text.
        g.ActiveId = activeId;                                                              // Restore active ID.
        if (!(flags & ImGuiComboFlags_NoArrowButton))                                       // If arrow enabled...
        {                                                                                   // Begin block.
            ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button); // BG color.
            ImU32 text_col = GetColorU32(ImGuiCol_Text);                                    // Text color.
            window->DrawList->AddRectFilled(ImVec2(value_x2, frame_bb.Min.y), frame_bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right); // Draw button bg.
            if (value_x2 + arrow_size - style.FramePadding.x <= frame_bb.Max.x)             // If space allows...
                RenderArrow(window->DrawList, ImVec2(value_x2 + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, 1.0f); // Render arrow.
        }                                                                                   // End block.
    }                                                                                       // End block.
    else                                                                                    // Else (idle state)...
    {                                                                                       // Begin block.
        ItemSize(total_bb, style.FramePadding.y);                                           // Declare size.
        if (!ItemAdd(total_bb, id, &frame_bb))                                              // Add item.
            return false;                                                                   // Early out.
    }                                                                                       // End block.

    if ((pressed || g.NavActivateId == id) && !popup_open)                                  // If activated...
    {                                                                                       // Begin block.
        if (window->DC.NavLayerCurrent == 0)                                                // If main layer...
            window->NavLastIds[0] = id;                                                     // Set nav ID.
        OpenPopupEx(id);                                                                    // Open popup.
        popup_open = true;                                                                  // Set flag.
    }                                                                                       // End block.

    if (!popup_open)                                                                        // If closed...
    {                                                                                       // Begin block.
        RenderNavHighlight(frame_bb, id);                                                   // Render highlight.
        if (!(flags & ImGuiComboFlags_NoPreview))                                           // If preview enabled...
            window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(value_x2, frame_bb.Max.y), frame_col, style.FrameRounding, (flags & ImGuiComboFlags_NoArrowButton) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Left); // Draw frame.
        if (!(flags & ImGuiComboFlags_NoArrowButton))                                       // If arrow enabled...
        {                                                                                   // Begin block.
            ImU32 bg_col = GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button); // BG color.
            ImU32 text_col = GetColorU32(ImGuiCol_Text);                                    // Text color.
            window->DrawList->AddRectFilled(ImVec2(value_x2, frame_bb.Min.y), frame_bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right); // Draw button.
            if (value_x2 + arrow_size - style.FramePadding.x <= frame_bb.Max.x)             // If space allows...
                RenderArrow(window->DrawList, ImVec2(value_x2 + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), text_col, ImGuiDir_Down, 1.0f); // Render arrow.
        }                                                                                   // End block.
        RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);                 // Draw border.

        if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))                  // If preview text...
            RenderTextClipped(frame_bb.Min + style.FramePadding, ImVec2(value_x2, frame_bb.Max.y), preview_value, NULL, NULL, ImVec2(0.0f, 0.0f)); // Draw text.
        if (label_size.x > 0)                                                               // If label exists...
            RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label); // Draw label.

        return false;                                                                       // Return false (not open).
    }                                                                                       // End block.

    if (has_window_size_constraint)                                                         // If constraint exists...
    {                                                                                       // Begin block.
        g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;               // Restore flag.
        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w); // Min width.
    }                                                                                       // End block.
    else                                                                                    // Else...
    {                                                                                       // Begin block.
        if ((flags & ImGuiComboFlags_HeightMask_) == 0)                                     // If no height flag...
            flags |= ImGuiComboFlags_HeightRegular;                                         // Default height.
        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one      // Assert power of two.
        int popup_max_height_in_items = -1;                                                 // Max items.
        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;       // 8 items.
        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;       // 4 items.
        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;      // 20 items.
        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items))); // Set constraint.
    }                                                                                       // End block.

    char name[16];                                                                          // Name buffer.
    ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth // Format name.

    // Peak into expected window size so we can position it                                  // Comment.
    if (ImGuiWindow* popup_window = FindWindowByName(name))                                 // Find window.
        if (popup_window->WasActive)                                                        // If active...
        {                                                                                   // Begin block.
            ImVec2 size_expected = CalcWindowExpectedSize(popup_window);                    // Calc size.
            if (flags & ImGuiComboFlags_PopupAlignLeft)                                     // If align left...
                popup_window->AutoPosLastDirection = ImGuiDir_Left;                         // Set direction.
            ImRect r_outer = GetWindowAllowedExtentRect(popup_window);                      // Get extent.
            ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox); // Find pos.
            SetNextWindowPos(pos);                                                          // Set pos.
        }                                                                                   // End block.

    // We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx() // Comment.
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoMove; // Flags.

    // Horizontally align ourselves with the framed text                                    // Comment.
    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y)); // Push var.
    bool ret = Begin(name, NULL, window_flags);                                             // Begin popup.
    PopStyleVar();                                                                          // Pop var.
    if (!ret)                                                                               // If failed...
    {                                                                                       // Begin block.
        EndPopup();                                                                         // End popup.
        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above    // Assert.
        return false;                                                                       // Return false.
    }                                                                                       // End block.

    return true;                                                                            // Return true.
}                                                                                           // End BeginSearchableCombo.


// Just so you can end your BeginSearchableCombo with EndSearchableCombo.                   // Comment.
void ImGui::EndSearchableCombo()                                                            // Implementation.
{                                                                                           // Begin.
    EndCombo();                                                                             // Call EndCombo.
}                                                                                           // End.


/* Modified version of Combo from imgui.cpp at line 9343,
 * to include a input field to be able to filter the combo values. */                       // Comment.
bool ImGui::SearchableCombo(const char* label, int* current_item, std::vector<std::string> items, const char* default_preview_text, const char* input_preview_value, int popup_max_height_in_items) // Implementation.
{                                                                                           // Begin.
    ImGuiContext& g = *GImGui;                                                              // Context.

    const char* preview_text = NULL;                                                        // Preview pointer.
    if (*current_item >= (int)items.size())                                                 // Validation.
        *current_item = 0;                                                                  // Clamp.
    if (*current_item >= 0 && *current_item < (int)items.size())                            // If valid...
        preview_text = items[*current_item].c_str();                                        // Use item text.
    else                                                                                    // Else...
        preview_text = default_preview_text;                                                // Use default.

    // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here. // Comment.
    if (popup_max_height_in_items != -1 && !(g.NextWindowData.Flags & ImGuiNextWindowDataFlags_HasSizeConstraint)) // If height set...
        SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items))); // Constrain.

    const int input_size = 64;                                                              // Input size.
    char input_buffer[input_size] = "";                                                     // Input buffer.
    if (!BeginSearchableCombo(label, preview_text, input_buffer, input_size, input_preview_value, ImGuiComboFlags_None)) // Begin combo.
        return false;                                                                       // Return false if closed.

    // Display items                                                                        // Comment.
    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed) // Comment.
    int matched_items = 0;                                                                  // Match count.
    bool value_changed = false;                                                             // Changed flag.
    for (int i = 0; i < (int)items.size(); i++)                                             // Loop items.
    {                                                                                       // Begin loop.
        char buffer[input_size] = "";                                                       // Buffer.
        ImStrncpy(buffer, input_buffer, input_size);                                        // Copy input.
        std::string input(buffer);                                                          // Create string.
        std::string item = items[i];                                                        // Create string.

        std::transform(item.begin(), item.end(), item.begin(),                              // Lowercase item.
            [](unsigned char c) { return (unsigned char)std::tolower(c); });                // Lambda.
        std::transform(input.begin(), input.end(), input.begin(),                           // Lowercase input.
            [](unsigned char c) { return (unsigned char)std::tolower(c); });                // Lambda.

        if (item.find(input, 0) == std::string::npos)                                       // Filter check.
            continue;                                                                       // Skip if no match.

        matched_items++;                                                                    // Increment matches.
        PushID((void*)(intptr_t)i);                                                         // Push ID.
        const bool item_selected = (i == *current_item);                                    // Check selection.
        const char* item_text = items[i].c_str();                                           // Get text.
        if (Selectable(item_text, item_selected))                                           // Draw selectable.
        {                                                                                   // Begin block.
            value_changed = true;                                                           // Set changed.
            *current_item = i;                                                              // Update selection.
        }                                                                                   // End block.
        if (item_selected)                                                                  // If selected...
            SetItemDefaultFocus();                                                          // Focus.
        PopID();                                                                            // Pop ID.
    }                                                                                       // End loop.
    if (matched_items == 0)                                                                 // If no matches...
        ImGui::Selectable("No maps found", false, ImGuiSelectableFlags_Disabled);           // Show "No maps".

    EndSearchableCombo();                                                                   // End combo.

    return value_changed;                                                                   // Return result.
}                                                                                           // End SearchableCombo.

// ======================================================================================
// FILE: IMGUI/imgui_rangeslider.h
// ======================================================================================
#pragma once                                                                                // Header guard.
#include "imgui.h"                                                                          // ImGui header.
namespace ImGui                                                                             // Extend ImGui namespace.
{                                                                                           // Begin.
    IMGUI_API bool RangeSliderScalar(const char* label, ImGuiDataType data_type, void* p_data1, void* p_data2, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f); // Scalar range slider.
    IMGUI_API bool RangeSliderScalarN(const char* label, ImGuiDataType data_type, void* p_data1, void* p_data2, int components, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f); // Multi-component scalar range slider.
    IMGUI_API bool RangeSliderFloat(const char* label, float* v1, float* v2, float v_min, float v_max, const char* format = "(%.3f, %.3f)", float power = 1.0f);     // adjust format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for power curve sliders // Float range slider.
    IMGUI_API bool RangeSliderFloat2(const char* label, float v1[2], float v2[2], float v_min, float v_max, const char* format = "(%.3f, %.3f)", float power = 1.0f); // Float2 range slider.
    IMGUI_API bool RangeSliderFloat3(const char* label, float v1[3], float v2[3], float v_min, float v_max, const char* format = "(%.3f, %.3f)", float power = 1.0f); // Float3 range slider.
    IMGUI_API bool RangeSliderFloat4(const char* label, float v1[4], float v2[4], float v_min, float v_max, const char* format = "(%.3f, %.3f)", float power = 1.0f); // Float4 range slider.
    IMGUI_API bool RangeSliderAngle(const char* label, float* v_rad1, float* v_rad2, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "(%d, %d) deg"); // Angle range slider.
    IMGUI_API bool RangeSliderInt(const char* label, int* v1, int* v2, int v_min, int v_max, const char* format = "(%d, %d)"); // Int range slider.
    IMGUI_API bool RangeSliderInt2(const char* label, int v1[2], int v2[2], int v_min, int v_max, const char* format = "(%d, %d)"); // Int2 range slider.
    IMGUI_API bool RangeSliderInt3(const char* label, int v1[3], int v2[3], int v_min, int v_max, const char* format = "(%d, %d)"); // Int3 range slider.
    IMGUI_API bool RangeSliderInt4(const char* label, int v1[4], int v2[4], int v_min, int v_max, const char* format = "(%d, %d)"); // Int4 range slider.
    IMGUI_API bool RangeVSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data1, void* p_data2, const void* p_min, const void* p_max, const char* format = NULL, float power = 1.0f); // Vertical scalar range slider.
    IMGUI_API bool RangeVSliderFloat(const char* label, const ImVec2& size, float* v1, float* v2, float v_min, float v_max, const char* format = "(%.3f, %.3f)", float power = 1.0f); // Vertical float range slider.
    IMGUI_API bool RangeVSliderInt(const char* label, const ImVec2& size, int* v1, int* v2, int v_min, int v_max, const char* format = "(%d, %d)"); // Vertical int range slider.

} // namespace ImGui                                                                        // End namespace.

// ======================================================================================
// FILE: IMGUI/imgui_rangeslider.cpp
// ======================================================================================
#include "pch.h"                                                                            // Precompiled header.
#include "imgui_rangeslider.h"                                                              // Header.
#include "imgui_internal.h"                                                                 // Internal for advanced usage.
#include <string>                                                                           // String support.

namespace ImGui                                                                             // Extend ImGui namespace.
{                                                                                           // Begin.
    //-------------------------------------------------------------------------             // Comment: Section.
    // Data                                                                                 // Comment.
    //-------------------------------------------------------------------------             // Comment.

    // Those MIN/MAX values are not define because we need to point to them                 // Comment.
    static const signed char    IM_S8_MIN  = -128;                                          // Min S8.
    static const signed char    IM_S8_MAX  = 127;                                           // Max S8.
    static const unsigned char  IM_U8_MIN  = 0;                                             // Min U8.
    static const unsigned char  IM_U8_MAX  = 0xFF;                                          // Max U8.
    static const signed short   IM_S16_MIN = -32768;                                        // Min S16.
    static const signed short   IM_S16_MAX = 32767;                                         // Max S16.
    static const unsigned short IM_U16_MIN = 0;                                             // Min U16.
    static const unsigned short IM_U16_MAX = 0xFFFF;                                        // Max U16.
    static const ImS32          IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);// Min S32.
    static const ImS32          IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)      // Max S32.
    static const ImU32          IM_U32_MIN = 0;                                             // Min U32.
    static const ImU32          IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)                    // Max U32.
#ifdef LLONG_MIN                                                                            // If LLONG_MIN defined...
    static const ImS64          IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll); // Min S64.
    static const ImS64          IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);        // Max S64.
#else                                                                                       // Else...
    static const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;                    // Min S64 literal.
    static const ImS64          IM_S64_MAX = 9223372036854775807LL;                         // Max S64 literal.
#endif                                                                                      // Endif.
    static const ImU64          IM_U64_MIN = 0;                                             // Min U64.
#ifdef ULLONG_MAX                                                                           // If ULLONG_MAX...
    static const ImU64          IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);        // Max U64.
#else                                                                                       // Else...
    static const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);            // Max U64 calc.
#endif                                                                                      // Endif.

    //-------------------------------------------------------------------------             // Comment: Section.
    // [SECTION] Data Type and Data Formatting Helpers [Internal]                           // Comment.
    //-------------------------------------------------------------------------             // Comment.
    // - PatchFormatStringFloatToInt()                                                      // Comment.
    // - DataTypeFormatString()                                                             // Comment.
    //-------------------------------------------------------------------------             // Comment.

    static const ImGuiDataTypeInfo GDataTypeInfo[] =                                        // Type info array.
    {                                                                                       // Begin.
        { sizeof(char),             "%d",   "%d"    },  // ImGuiDataType_S8                 // S8 info.
        { sizeof(unsigned char),    "%u",   "%u"    },                                      // U8 info.
        { sizeof(short),            "%d",   "%d"    },  // ImGuiDataType_S16                // S16 info.
        { sizeof(unsigned short),   "%u",   "%u"    },                                      // U16 info.
        { sizeof(int),              "%d",   "%d"    },  // ImGuiDataType_S32                // S32 info.
        { sizeof(unsigned int),     "%u",   "%u"    },                                      // U32 info.
    #ifdef _MSC_VER                                                                         // If MSVC...
        { sizeof(ImS64),            "%I64d","%I64d" },  // ImGuiDataType_S64                // S64 info.
        { sizeof(ImU64),            "%I64u","%I64u" },                                      // U64 info.
    #else                                                                                   // Else...
        { sizeof(ImS64),            "%lld", "%lld"  },  // ImGuiDataType_S64                // S64 info.
        { sizeof(ImU64),            "%llu", "%llu"  },                                      // U64 info.
    #endif                                                                                  // Endif.
        { sizeof(float),            "%f",   "%f"    },  // ImGuiDataType_Float (float are promoted to double in va_arg) // Float info.
        { sizeof(double),           "%f",   "%lf"   },  // ImGuiDataType_Double             // Double info.
    };                                                                                      // End array.
    IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);                   // Assert size match.

    // ~65% common code with PatchFormatStringFloatToInt.                                   // Comment.
    // FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats...         // Comment.
    static const char* PatchFormatStringFloatToInt(const char* fmt)                         // Helper function.
    {                                                                                       // Begin.
        if (strcmp(fmt, "(%.0f, %.0f)") == 0) // Fast legacy path for "(%.0f, %.0f)" which is expected to be the most common case. // Check legacy.
            return "(%d, %d)";                                                              // Return replacement.

        // Find % (if any, and ignore %%)                                                   // Comment.
        ImGuiContext& g = *GImGui;                                                          // Context.
        g.TempBuffer[0] = '\0';                                                             // Clear temp.
        for (const char* fmt_b = fmt; char c = fmt_b[0]; fmt_b++)                           // Loop format.
        {                                                                                   // Begin loop.
            if (c == '%' && fmt_b[1] != '%')                                                // If specifier...
            {                                                                               // Begin block.
                const char* fmt_start = fmt_b;                                              // Start ptr.
                const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier... // End ptr.
                if (fmt_end > fmt_start&& fmt_end[-1] == 'f')                               // If float...
                {                                                                           // Begin block.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS                                                    // If enabled...
                    ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), "%.*s%%d%s", (int)(fmt_start - fmt_b), fmt_b, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision. // Convert.
#else                                                                                       // Else...
                    IM_ASSERT(0 && "DragInt(): Invalid format string!"); // Old versions used a default parameter of "(%.0f, %.0f)", please replace with e.g. "(%d, %d)" // Assert.
#endif                                                                                      // Endif.
                }                                                                           // End block.
            }                                                                               // End block.
            else if (c == '%')                                                              // If escaped...
                fmt_b++;                                                                    // Skip.
        }                                                                                   // End loop.

        if (g.TempBuffer[0] == '\0')                                                        // If no change...
            return fmt;                                                                     // Return original.
        return g.TempBuffer;                                                                // Return modified.
    }                                                                                       // End function.

    int DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data1, const void* p_data2, const char* format) // Implementation.
    {                                                                                       // Begin.
        // Signedness doesn't matter when pushing integer arguments                         // Comment.
        if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)               // S32/U32.
            return ImFormatString(buf, buf_size, format, *(const ImU32*)p_data1, *(const ImU32*)p_data2); // Format.
        if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)               // S64/U64.
            return ImFormatString(buf, buf_size, format, *(const ImU64*)p_data1, *(const ImU64*)p_data2); // Format.
        if (data_type == ImGuiDataType_Float)                                               // Float.
            return ImFormatString(buf, buf_size, format, *(const float*)p_data1, *(const float*)p_data2); // Format.
        if (data_type == ImGuiDataType_Double)                                              // Double.
            return ImFormatString(buf, buf_size, format, *(const double*)p_data1, *(const double*)p_data2); // Format.
        if (data_type == ImGuiDataType_S8)                                                  // S8.
            return ImFormatString(buf, buf_size, format, *(const ImS8*)p_data1, *(const ImS8*)p_data2); // Format.
        if (data_type == ImGuiDataType_U8)                                                  // U8.
            return ImFormatString(buf, buf_size, format, *(const ImU8*)p_data1, *(const ImU8*)p_data2); // Format.
        if (data_type == ImGuiDataType_S16)                                                 // S16.
            return ImFormatString(buf, buf_size, format, *(const ImS16*)p_data1, *(const ImS16*)p_data2); // Format.
        if (data_type == ImGuiDataType_U16)                                                 // U16.
            return ImFormatString(buf, buf_size, format, *(const ImU16*)p_data1, *(const ImU16*)p_data2); // Format.
        IM_ASSERT(0);                                                                       // Assert.
        return 0;                                                                           // Return 0.
    }                                                                                       // End function.

    //-------------------------------------------------------------------------             // Comment: Section.
    // [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.                        // Comment.
    //-------------------------------------------------------------------------             // Comment.
    // - RangeSliderBehaviorT<>() [Internal]                                                // Comment.
    // - RangeSliderBehavior() [Internal]                                                   // Comment.
    // - RangeSliderScalar()                                                                // Comment.
    // - RangeSliderFloat()                                                                 // Comment.
    // - RangeSliderAngle()                                                                 // Comment.
    // - RangeSliderInt()                                                                   // Comment.
    //-------------------------------------------------------------------------             // Comment.

    // ~80% common code with ImGui::SliderBehaviorT.                                        // Comment.
    // FIXME: Move some of the code into SliderBehavior(). Current responsability is larger than what the equivalent DragBehaviorT<> does, we also do some rendering, etc. // Comment.
    template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>                        // Template.
    bool RangeSliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v1, TYPE* v2, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab1_bb, ImRect* out_grab2_bb) // Implementation.
    {                                                                                       // Begin.
        ImGuiContext& g = *GImGui;                                                          // Context.
        const ImGuiStyle& style = g.Style;                                                  // Style.

        const ImGuiAxis axis = (flags & ImGuiSliderFlags_Vertical) ? ImGuiAxis_Y : ImGuiAxis_X; // Axis.
        const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double); // Decimal check.
        const bool is_power = (power != 1.0f) && is_decimal;                                // Power check.

        const float grab_padding = 2.0f;                                                    // Padding.
        const float slider_sz = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0f;        // Size.
        float grab_sz = style.GrabMinSize;                                                  // Default grab size.
        SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);               // Range.
        if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows // Check range.
            grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit // Calc size.
        grab_sz = ImMin(grab_sz, slider_sz);                                                // Clamp size.
        const float slider_usable_sz = slider_sz - grab_sz;                                 // Usable size.
        const float slider_usable_pos_min = bb.Min[axis] + grab_padding + grab_sz * 0.5f;   // Min pos.
        const float slider_usable_pos_max = bb.Max[axis] - grab_padding - grab_sz * 0.5f;   // Max pos.

        // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f // Comment.
        float linear_zero_pos;   // 0.0->1.0f                                               // Zero pos.
        if (is_power && v_min * v_max < 0.0f)                                               // If power and crossed signs...
        {                                                                                   // Begin block.
            // Different sign                                                               // Comment.
            const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f / power); // Calc min dist.
            const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f / power); // Calc max dist.
            linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0)); // Calc pos.
        }                                                                                   // End block.
        else                                                                                // Else...
        {                                                                                   // Begin block.
            // Same sign                                                                    // Comment.
            linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;                                   // Calc pos.
        }                                                                                   // End block.

        // Process interacting with the slider                                              // Comment.
        bool value_changed = false;                                                         // Change flag.
        if (g.ActiveId == id)                                                               // If active...
        {                                                                                   // Begin block.
            bool set_v_new = false;                                                         // Set flag.
            static int lastDrag = -1;                                                       // Drag state.
            float clicked_t = 0.0f;                                                         // T value.
            if (g.ActiveIdSource == ImGuiInputSource_Mouse)                                 // If mouse...
            {                                                                               // Begin block.
                if (!g.IO.MouseDown[0])                                                     // If released...
                {                                                                           // Begin block.
                    ClearActiveID();                                                        // Clear active.
                }                                                                           // End block.
                else                                                                        // Else...
                {                                                                           // Begin block.
                    const float mouse_abs_pos = g.IO.MousePos[axis];                        // Mouse pos.
                    clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f; // Calc t.
                    if (axis == ImGuiAxis_Y)                                                // If vertical...
                        clicked_t = 1.0f - clicked_t;                                       // Invert.
                    set_v_new = true;                                                       // Set flag.
                }                                                                           // End block.
            }                                                                               // End block.
            else if (g.ActiveIdSource == ImGuiInputSource_Nav)                              // If nav...
            {                                                                               // Begin block.
                const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f); // Get delta.
                float delta = (axis == ImGuiAxis_X) ? delta2.x : -delta2.y;                 // Select axis.
                if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)             // If activated...
                {                                                                           // Begin block.
                    ClearActiveID();                                                        // Clear.
                }                                                                           // End block.
                else if (delta != 0.0f)                                                     // If moving...
                {                                                                           // Begin block.
                    clicked_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v1, v_min, v_max, power, linear_zero_pos); // Calc current t.
                    const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0; // Precision.
                    if ((decimal_precision > 0) || is_power)                                // If float/power...
                    {                                                                       // Begin block.
                        delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds // Scale delta.
                        if (IsNavInputDown(ImGuiNavInput_TweakSlow))                        // If slow...
                            delta /= 10.0f;                                                 // Reduce.
                    }                                                                       // End block.
                    else                                                                    // Else...
                    {                                                                       // Begin block.
                        if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow)) // Check range.
                            delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps // Discrete step.
                        else                                                                // Else...
                            delta /= 100.0f;                                                // Continuous.
                    }                                                                       // End block.
                    if (IsNavInputDown(ImGuiNavInput_TweakFast))                            // If fast...
                        delta *= 10.0f;                                                     // Increase.
                    set_v_new = true;                                                       // Set flag.
                    if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits // Bounds check.
                        set_v_new = false;                                                  // Clear flag.
                    else                                                                    // Else...
                        clicked_t = ImSaturate(clicked_t + delta);                          // Apply.
                }                                                                           // End block.
            }                                                                               // End block.

            if (set_v_new)                                                                  // If update...
            {                                                                               // Begin block.
                TYPE v_new;                                                                 // New value.
                if (is_power)                                                               // If power...
                {                                                                           // Begin block.
                    // Account for power curve scale on both sides of the zero              // Comment.
                    if (clicked_t < linear_zero_pos)                                        // If negative side...
                    {                                                                       // Begin block.
                        // Negative: rescale to the negative range before powering          // Comment.
                        float a = 1.0f - (clicked_t / linear_zero_pos);                     // Calc a.
                        a = ImPow(a, power);                                                // Power.
                        v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);                    // Lerp.
                    }                                                                       // End block.
                    else                                                                    // Else...
                    {                                                                       // Begin block.
                        // Positive: rescale to the positive range before powering          // Comment.
                        float a;                                                            // Var.
                        if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)                        // Check zero pos.
                            a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);   // Calc a.
                        else                                                                // Else...
                            a = clicked_t;                                                  // Calc a.
                        a = ImPow(a, power);                                                // Power.
                        v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);                    // Lerp.
                    }                                                                       // End block.
                }                                                                           // End block.
                else                                                                        // Else...
                {                                                                           // Begin block.
                    // Linear slider                                                        // Comment.
                    if (is_decimal)                                                         // If decimal...
                    {                                                                       // Begin block.
                        v_new = ImLerp(v_min, v_max, clicked_t);                            // Lerp.
                    }                                                                       // End block.
                    else                                                                    // Else...
                    {                                                                       // Begin block.
                        // For integer values we want the clicking position to match the grab box so we round above // Comment.
                        // This code is carefully tuned to work with large values...        // Comment.
                        FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;                // Calc offset.
                        TYPE v_new_off_floor = (TYPE)(v_new_off_f);                         // Floor.
                        TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);        // Round.
                        if (v_new_off_floor < v_new_off_round)                              // Compare.
                            v_new = v_min + v_new_off_round;                                // Add round.
                        else                                                                // Else.
                            v_new = v_min + v_new_off_floor;                                // Add floor.
                    }                                                                       // End block.
                }                                                                           // End block.

                // Round to user desired precision based on format string                   // Comment.
                v_new = RoundScalarWithFormatT<TYPE, SIGNEDTYPE>(format, data_type, v_new); // Round.

                // Apply result                                                             // Comment.
                if (*v1 != v_new || *v2 != v_new)                                           // If changed...
                {                                                                           // Begin block.
                    if (lastDrag == 1 || lastDrag == 2)                                     // If drag 1/2...
                    {                                                                       // Begin block.
                        if (*v2 == v_new)                                                   // If match v2...
                        {                                                                   // Begin block.
                            *v1 = v_new;                                                    // Update v1.
                            lastDrag = 2; //left to right, just hit same spot               // Update state.
                        }                                                                   // End block.
                    }                                                                       // End block.
                    else if (lastDrag == 0 || lastDrag == 3)                                // If drag 0/3...
                    {                                                                       // Begin block.
                        if (*v1 == v_new)                                                   // If match v1...
                        {                                                                   // Begin block.
                            *v2 = v_new;                                                    // Update v2.
                            lastDrag = 3; //right to left, just hit left spot               // Update state.
                        }                                                                   // End block.
                    }                                                                       // End block.
                    if (ImFabs(*v1 - v_new) == ImFabs(*v2 - v_new))                         // If equidistant...
                    {                                                                       // Begin block.
                        if (*v1 == *v2)                                                     // If equal...
                        {                                                                   // Begin block.
                            if (*v1 != v_new)                                               // If new != v1...
                            {                                                               // Begin block.
                                if (v_new > * v1)                                           // If greater...
                                {                                                           // Begin block.
                                    *v2 = v_new;                                            // Set v2.
                                }                                                           // End block.
                                else                                                        // Else...
                                {                                                           // Begin block.
                                    *v1 = v_new;                                            // Set v1.
                                }                                                           // End block.
                            }                                                               // End block.
                        }                                                                   // End block.
                        //else                                                              // Comment.
                        if (lastDrag == 1)                                                  // If last 1...
                        {                                                                   // Begin block.
                            *v1 = v_new;                                                    // Set v1.
                        }                                                                   // End block.
                        else if (lastDrag == 0)                                             // If last 0...
                        {                                                                   // Begin block.
                            *v2 = v_new;                                                    // Set v2.
                        }                                                                   // End block.

                    }                                                                       // End block.
                    else if (ImFabs(*v1 - v_new) < ImFabs(*v2 - v_new))                     // If closer to v1...
                    {                                                                       // Begin block.
                        *v1 = v_new;                                                        // Set v1.
                        lastDrag = 1;                                                       // Set state.
                    }                                                                       // End block.
                    else                                                                    // Else...
                    {                                                                       // Begin block.
                        *v2 = v_new;                                                        // Set v2.
                        lastDrag = 0;                                                       // Set state.
                    }                                                                       // End block.
                    value_changed = true;                                                   // Set flag.
                }                                                                           // End block.
            }                                                                               // End block.
        }                                                                                   // End block.

        if (slider_sz < 1.0f)                                                               // If too small...
        {                                                                                   // Begin block.
            *out_grab1_bb = ImRect(bb.Min, bb.Min);                                         // Empty rect.
            *out_grab2_bb = ImRect(bb.Min, bb.Min);                                         // Empty rect.
        }                                                                                   // End block.
        else                                                                                // Else...
        {                                                                                   // Begin block.
            // Output grab1 position so it can be displayed by the caller                   // Comment.
            float grab1_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v1, v_min, v_max, power, linear_zero_pos); // Calc t1.
            if (axis == ImGuiAxis_Y)                                                        // If Y...
                grab1_t = 1.0f - grab1_t;                                                   // Invert.
            const float grab1_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab1_t); // Lerp pos.
            if (axis == ImGuiAxis_X)                                                        // If X...
                *out_grab1_bb = ImRect(grab1_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab1_pos + grab_sz * 0.5f, bb.Max.y - grab_padding); // Rect.
            else                                                                            // Else...
                *out_grab1_bb = ImRect(bb.Min.x + grab_padding, grab1_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab1_pos + grab_sz * 0.5f); // Rect.

            // Output grab2 position so it can be displayed by the caller                   // Comment.
            float grab2_t = SliderCalcRatioFromValueT<TYPE, FLOATTYPE>(data_type, *v2, v_min, v_max, power, linear_zero_pos); // Calc t2.
            if (axis == ImGuiAxis_Y)                                                        // If Y...
                grab2_t = 1.0f - grab2_t;                                                   // Invert.
            const float grab2_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab2_t); // Lerp pos.
            if (axis == ImGuiAxis_X)                                                        // If X...
                *out_grab2_bb = ImRect(grab2_pos - grab_sz * 0.5f, bb.Min.y + grab_padding, grab2_pos + grab_sz * 0.5f, bb.Max.y - grab_padding); // Rect.
            else                                                                            // Else...
                *out_grab2_bb = ImRect(bb.Min.x + grab_padding, grab2_pos - grab_sz * 0.5f, bb.Max.x - grab_padding, grab2_pos + grab_sz * 0.5f); // Rect.
        }                                                                                   // End block.

        return value_changed;                                                               // Return result.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderBehavior.                                         // Comment.
    // For 32-bit and larger types, slider bounds are limited to half the natural type range. // Comment.
    // So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail...                // Comment.
    // It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders. // Comment.
    bool RangeSliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v1, void* p_v2, const void* p_min, const void* p_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab1_bb, ImRect* out_grab2_bb) // Implementation.
    {                                                                                       // Begin.
        switch (data_type)                                                                  // Switch type.
        {                                                                                   // Begin block.
        case ImGuiDataType_S8:                                                              // S8.
        {                                                                                   // Begin block.
            ImS32 v32_1 = (ImS32) * (ImS8*)p_v1;                                            // Cast.
            ImS32 v32_2 = (ImS32) * (ImS8*)p_v2;                                            // Cast.
            bool r = RangeSliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32_1, &v32_2, *(const ImS8*)p_min, *(const ImS8*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
            if (r)                                                                          // If changed...
            {                                                                               // Begin block.
                *(ImS8*)p_v1 = (ImS8)v32_1;                                                 // Assign.
                *(ImS8*)p_v2 = (ImS8)v32_2;                                                 // Assign.
            }                                                                               // End block.
            return r;                                                                       // Return.
        }                                                                                   // End block.
        case ImGuiDataType_U8:                                                              // U8.
        {                                                                                   // Begin block.
            ImU32 v32_1 = (ImU32) * (ImU8*)p_v1;                                            // Cast.
            ImU32 v32_2 = (ImU32) * (ImU8*)p_v2;                                            // Cast.
            bool r = RangeSliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32_1, &v32_2, *(const ImU8*)p_min, *(const ImU8*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
            if (r)                                                                          // If changed...
            {                                                                               // Begin block.
                *(ImU8*)p_v1 = (ImU8)v32_1;                                                 // Assign.
                *(ImU8*)p_v2 = (ImU8)v32_2;                                                 // Assign.
            }                                                                               // End block.
            return r;                                                                       // Return.
        }                                                                                   // End block.
        case ImGuiDataType_S16:                                                             // S16.
        {                                                                                   // Begin block.
            ImS32 v32_1 = (ImS32) * (ImS16*)p_v1;                                           // Cast.
            ImS32 v32_2 = (ImS32) * (ImS16*)p_v2;                                           // Cast.
            bool r = RangeSliderBehaviorT<ImS32, ImS32, float>(bb, id, ImGuiDataType_S32, &v32_1, &v32_2, *(const ImS16*)p_min, *(const ImS16*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
            if (r)                                                                          // If changed...
            {                                                                               // Begin block.
                *(ImS16*)p_v1 = (ImS16)v32_1;                                               // Assign.
                *(ImS16*)p_v2 = (ImS16)v32_2;                                               // Assign.
            }                                                                               // End block.
            return r;                                                                       // Return.
        }                                                                                   // End block.
        case ImGuiDataType_U16:                                                             // U16.
        {                                                                                   // Begin block.
            ImU32 v32_1 = (ImU32) * (ImU16*)p_v1;                                           // Cast.
            ImU32 v32_2 = (ImU32) * (ImU16*)p_v2;                                           // Cast.
            bool r = RangeSliderBehaviorT<ImU32, ImS32, float>(bb, id, ImGuiDataType_U32, &v32_1, &v32_2, *(const ImU16*)p_min, *(const ImU16*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
            if (r)                                                                          // If changed...
            {                                                                               // Begin block.
                *(ImU16*)p_v1 = (ImU16)v32_1;                                               // Assign.
                *(ImU16*)p_v2 = (ImU16)v32_2;                                               // Assign.
            }                                                                               // End block.
            return r;                                                                       // Return.
        }                                                                                   // End block.
        case ImGuiDataType_S32:                                                             // S32.
            IM_ASSERT(*(const ImS32*)p_min >= IM_S32_MIN / 2 && *(const ImS32*)p_max <= IM_S32_MAX / 2); // Assert bounds.
            return RangeSliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)p_v1, (ImS32*)p_v2, *(const ImS32*)p_min, *(const ImS32*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
        case ImGuiDataType_U32:                                                             // U32.
            IM_ASSERT(*(const ImU32*)p_max <= IM_U32_MAX / 2);                              // Assert bounds.
            return RangeSliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)p_v1, (ImU32*)p_v2, *(const ImU32*)p_min, *(const ImU32*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
        case ImGuiDataType_S64:                                                             // S64.
            IM_ASSERT(*(const ImS64*)p_min >= IM_S64_MIN / 2 && *(const ImS64*)p_max <= IM_S64_MAX / 2); // Assert bounds.
            return RangeSliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)p_v1, (ImS64*)p_v2, *(const ImS64*)p_min, *(const ImS64*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
        case ImGuiDataType_U64:                                                             // U64.
            IM_ASSERT(*(const ImU64*)p_max <= IM_U64_MAX / 2);                              // Assert bounds.
            return RangeSliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)p_v1, (ImU64*)p_v2, *(const ImU64*)p_min, *(const ImU64*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
        case ImGuiDataType_Float:                                                           // Float.
            IM_ASSERT(*(const float*)p_min >= -FLT_MAX / 2.0f && *(const float*)p_max <= FLT_MAX / 2.0f); // Assert bounds.
            return RangeSliderBehaviorT<float, float, float >(bb, id, data_type, (float*)p_v1, (float*)p_v2, *(const float*)p_min, *(const float*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
        case ImGuiDataType_Double:                                                          // Double.
            IM_ASSERT(*(const double*)p_min >= -DBL_MAX / 2.0f && *(const double*)p_max <= DBL_MAX / 2.0f); // Assert bounds.
            return RangeSliderBehaviorT<double, double, double>(bb, id, data_type, (double*)p_v1, (double*)p_v2, *(const double*)p_min, *(const double*)p_max, format, power, flags, out_grab1_bb, out_grab2_bb); // Call T.
        case ImGuiDataType_COUNT: break;                                                    // Count.
        }                                                                                   // End switch.
        IM_ASSERT(0);                                                                       // Assert.
        return false;                                                                       // Return.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderScalar                                            // Comment.
    // Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a slider, they are all required. // Comment.
    // Read code of e.g. SliderFloat(), SliderInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly. // Comment.
    bool ImGui::RangeSliderScalar(const char* label, ImGuiDataType data_type, void* p_data1, void* p_data2, const void* p_min, const void* p_max, const char* format, float power) // Implementation.
    {                                                                                       // Begin.
        ImGuiWindow* window = GetCurrentWindow();                                           // Get window.
        if (window->SkipItems)                                                              // If skip...
            return false;                                                                   // Return.

        ImGuiContext& g = *GImGui;                                                          // Context.
        const ImGuiStyle& style = g.Style;                                                  // Style.
        const ImGuiID id = window->GetID(label);                                            // ID.
        const float w = CalcItemWidth();                                                    // Width.

        const ImVec2 label_size = CalcTextSize(label, NULL, true);                          // Label size.
        const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f)); // Frame BB.
        const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f)); // Total BB.

        ItemSize(total_bb, style.FramePadding.y);                                           // Declare size.
        if (!ItemAdd(total_bb, id, &frame_bb))                                              // Add item.
            return false;                                                                   // Return.

        // Default format string when passing NULL                                          // Comment.
        if (format == NULL)                                                                 // If null...
            format = (std::string("(") + DataTypeGetInfo(data_type)->PrintFmt + ", " + DataTypeGetInfo(data_type)->PrintFmt + ")").c_str(); // Default.
        else if (data_type == ImGuiDataType_S32 && strcmp(format, "(%d, %d)") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.) // Check legacy.
            format = PatchFormatStringFloatToInt(format);                                   // Patch.

        // Tabbing or CTRL-clicking on Slider turns it into an input box                    // Comment.
        const bool hovered = ItemHoverable(frame_bb, id);                                   // Hover check.
        bool temp_input_is_active = TempInputTextIsActive(id);                              // Temp input check.
        bool temp_input_start = false;                                                      // Start flag.
        if (!temp_input_is_active)                                                          // If not input...
        {                                                                                   // Begin block.
            //const bool focus_requested = FocusableItemRegister(window, id);               // Comment.
            const bool focus_requested = FocusableItemRegister(window, g.ActiveId == id);   // Focus check.
            const bool clicked = (hovered && g.IO.MouseClicked[0]);                         // Click check.
            if (focus_requested || clicked || g.NavActivateId == id || g.NavInputId == id)  // If activating...
            {                                                                               // Begin block.
                SetActiveID(id, window);                                                    // Set active.
                SetFocusID(id, window);                                                     // Set focus.
                FocusWindow(window);                                                        // Focus window.
                g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);  // Nav flags.
                if (focus_requested || (clicked && g.IO.KeyCtrl) || g.NavInputId == id)     // If text input request...
                {                                                                           // Begin block.
                    temp_input_start = true;                                                // Set start.
                    FocusableItemUnregister(window);                                        // Unregister.
                }                                                                           // End block.
            }                                                                               // End block.
        }                                                                                   // End block.
        if (temp_input_is_active || temp_input_start)                                       // If input mode...
            return TempInputTextScalar(frame_bb, id, label, data_type, p_data1, format);    // Return temp input.

        // Draw frame                                                                       // Comment.
        const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg); // Frame color.
        RenderNavHighlight(frame_bb, id);                                                   // Nav highlight.
        RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);    // Render frame.

        // Slider behavior                                                                  // Comment.
        ImRect grab_bb1, grab_bb2;                                                          // Grab rects.
        const bool value_changed = RangeSliderBehavior(frame_bb, id, data_type, p_data1, p_data2, p_min, p_max, format, power, ImGuiSliderFlags_None, &grab_bb1, &grab_bb2); // Behavior.
        if (value_changed)                                                                  // If changed...
            MarkItemEdited(id);                                                             // Mark edited.

        // Render grabs                                                                     // Comment.
        if (grab_bb1.Max.x > grab_bb1.Min.x)                                                // If visible...
            window->DrawList->AddRectFilled(grab_bb1.Min, grab_bb1.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding); // Draw grab 1.
        if (grab_bb2.Max.x > grab_bb2.Min.x)                                                // If visible...
            window->DrawList->AddRectFilled(grab_bb2.Min, grab_bb2.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding); // Draw grab 2.
        // Render connector                                                                 // Comment.
        ImRect connector(grab_bb1.Min, grab_bb2.Max);                                       // Connector rect.
        float grab_sz = grab_bb1.Max.x - grab_bb1.Min.x;                                    // Grab size.
        connector.Min.x += grab_sz;                                                         // Adjust min.
        connector.Min.y += grab_sz * 0.3f;                                                  // Adjust min Y.
        connector.Max.x -= grab_sz;                                                         // Adjust max.
        connector.Max.y -= grab_sz * 0.3f;                                                  // Adjust max Y.
        window->DrawList->AddRectFilled(connector.Min, connector.Max, GetColorU32(ImGuiCol_RangeSliderBar), style.GrabRounding); // Draw connector.

        // Display value using user-provided display format so user can add prefix/suffix/decorations to the value. // Comment.
        char value_buf[64];                                                                 // Buffer.
        const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data1, p_data2, format); // Format.
        RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f)); // Render text.

        if (label_size.x > 0.0f)                                                            // If label...
            RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label); // Render label.

        IMGUI_TEST_ENGINE_ITEM_INFO(id, label, window->DC.ItemFlags);                       // Test engine.
        return value_changed;                                                               // Return result.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderScalarN                                           // Comment.
    // Add multiple sliders on 1 line for compact edition of multiple components            // Comment.
    bool ImGui::RangeSliderScalarN(const char* label, ImGuiDataType data_type, void* v1, void* v2, int components, const void* v_min, const void* v_max, const char* format, float power) // Implementation.
    {                                                                                       // Begin.
        ImGuiWindow* window = GetCurrentWindow();                                           // Get window.
        if (window->SkipItems)                                                              // Check skip.
            return false;                                                                   // Return.

        ImGuiContext& g = *GImGui;                                                          // Context.
        bool value_changed = false;                                                         // Changed flag.
        BeginGroup();                                                                       // Begin group.
        PushID(label);                                                                      // Push ID.
        PushMultiItemsWidths(components, CalcItemWidth());                                  // Push widths.
        size_t type_size = GDataTypeInfo[data_type].Size;                                   // Get type size.
        for (int i = 0; i < components; i++)                                                // Loop components.
        {                                                                                   // Begin loop.
            PushID(i);                                                                      // Push sub ID.
            if (i > 0)                                                                      // If not first...
                SameLine(0, g.Style.ItemInnerSpacing.x);                                    // Same line.
            value_changed |= RangeSliderScalar("", data_type, v1, v2, v_min, v_max, format, power); // Render scalar.
            PopID();                                                                        // Pop sub ID.
            PopItemWidth();                                                                 // Pop width.
            v1 = (void*)((char*)v1 + type_size);                                            // Advance ptr.
            v2 = (void*)((char*)v2 + type_size);                                            // Advance ptr.
        }                                                                                   // End loop.
        PopID();                                                                            // Pop ID.

        const char* label_end = FindRenderedTextEnd(label);                                 // Find label end.
        if (label != label_end)                                                             // If label exists...
        {                                                                                   // Begin block.
            SameLine(0, g.Style.ItemInnerSpacing.x);                                        // Same line.
            TextEx(label, label_end);                                                       // Render text.
        }                                                                                   // End block.

        EndGroup();                                                                         // End group.
        return value_changed;                                                               // Return result.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderFloat                                             // Comment.
    bool ImGui::RangeSliderFloat(const char* label, float* v1, float* v2, float v_min, float v_max, const char* format, float power) // Implementation.
    {                                                                                       // Begin.
        return RangeSliderScalar(label, ImGuiDataType_Float, v1, v2, &v_min, &v_max, format, power); // Call Scalar.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderFloat2                                            // Comment.
    bool ImGui::RangeSliderFloat2(const char* label, float v1[2], float v2[2], float v_min, float v_max, const char* format, float power) // Implementation.
    {                                                                                       // Begin.
        return RangeSliderScalarN(label, ImGuiDataType_Float, v1, v2, 2, &v_min, &v_max, format, power); // Call ScalarN.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderFloat3                                            // Comment.
    bool ImGui::RangeSliderFloat3(const char* label, float v1[3], float v2[3], float v_min, float v_max, const char* format, float power) // Implementation.
    {                                                                                       // Begin.
        return RangeSliderScalarN(label, ImGuiDataType_Float, v1, v2, 3, &v_min, &v_max, format, power); // Call ScalarN.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderFloat4                                            // Comment.
    bool ImGui::RangeSliderFloat4(const char* label, float v1[4], float v2[4], float v_min, float v_max, const char* format, float power) // Implementation.
    {                                                                                       // Begin.
        return RangeSliderScalarN(label, ImGuiDataType_Float, v1, v2, 4, &v_min, &v_max, format, power); // Call ScalarN.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderAngle                                             // Comment.
    bool ImGui::RangeSliderAngle(const char* label, float* v_rad1, float* v_rad2, float v_degrees_min, float v_degrees_max, const char* format) // Implementation.
    {                                                                                       // Begin.
        if (format == NULL)                                                                 // If null...
            format = "%d deg";                                                              // Default.
        float v_deg1 = (*v_rad1) * 360.0f / (2 * IM_PI);                                    // Convert to deg.
        float v_deg2 = (*v_rad2) * 360.0f / (2 * IM_PI);                                    // Convert to deg.
        bool value_changed = RangeSliderFloat(label, &v_deg2, &v_deg1, v_degrees_min, v_degrees_max, format, 1.0f); // Call Float.
        *v_rad1 = v_deg1 * (2 * IM_PI) / 360.0f;                                            // Convert to rad.
        *v_rad2 = v_deg2 * (2 * IM_PI) / 360.0f;                                            // Convert to rad.
        return value_changed;                                                               // Return result.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderInt                                               // Comment.
    bool ImGui::RangeSliderInt(const char* label, int* v1, int* v2, int v_min, int v_max, const char* format) // Implementation.
    {                                                                                       // Begin.
        return RangeSliderScalar(label, ImGuiDataType_S32, v1, v2, &v_min, &v_max, format); // Call Scalar.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderInt2                                              // Comment.
    bool ImGui::RangeSliderInt2(const char* label, int v1[2], int v2[2], int v_min, int v_max, const char* format) // Implementation.
    {                                                                                       // Begin.
        return RangeSliderScalarN(label, ImGuiDataType_S32, v1, v2, 2, &v_min, &v_max, format); // Call ScalarN.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderInt3                                              // Comment.
    bool ImGui::RangeSliderInt3(const char* label, int v1[3], int v2[3], int v_min, int v_max, const char* format) // Implementation.
    {                                                                                       // Begin.
        return RangeSliderScalarN(label, ImGuiDataType_S32, v1, v2, 3, &v_min, &v_max, format); // Call ScalarN.
    }                                                                                       // End function.

    // ~95% common code with ImGui::SliderInt4                                              // Comment.
    bool ImGui::RangeSliderInt4(const char* label, int v1[4], int v2[4], int v_min, int v_max, const char* format) // Implementation.
    {                                                                                       // Begin.
        return RangeSliderScalarN(label, ImGuiDataType_S32, v1, v2, 4, &v_min, &v_max, format); // Call ScalarN.
    }                                                                                       // End function.

    bool ImGui::RangeVSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data1, void* p_data2, const void* p_min, const void* p_max, const char* format, float power) // Implementation.
    {                                                                                       // Begin.
        ImGuiWindow* window = GetCurrentWindow();                                           // Get window.
        if (window->SkipItems)                                                              // Check skip.
            return false;                                                                   // Return.

        ImGuiContext& g = *GImGui;                                                          // Context.
        const ImGuiStyle& style = g.Style;                                                  // Style.
        const ImGuiID id = window->GetID(label);                                            // ID.

        const ImVec2 label_size = CalcTextSize(label, NULL, true);                          // Label size.
        const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);           // Frame BB.
        const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f)); // Total BB.

        ItemSize(bb, style.FramePadding.y);                                                 // Declare size.
        if (!ItemAdd(frame_bb, id))                                                         // Add item.
            return false;                                                                   // Return.

        // Default format string when passing NULL                                          // Comment.
        if (format == NULL)                                                                 // If null...
            format = DataTypeGetInfo(data_type)->PrintFmt;                                  // Default.
        else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0) // (FIXME-LEGACY: Patch old "%.0f" format string to use "%d", read function more details.) // Check legacy.
            format = PatchFormatStringFloatToInt(format);                                   // Patch.

        const bool hovered = ItemHoverable(frame_bb, id);                                   // Hover check.
        if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id) // Activate check.
        {                                                                                   // Begin block.
            SetActiveID(id, window);                                                        // Set active.
            SetFocusID(id, window);                                                         // Set focus.
            FocusWindow(window);                                                            // Focus window.
            g.ActiveIdUsingNavDirMask |= (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);         // Nav flags.
        }                                                                                   // End block.

        // Draw frame                                                                       // Comment.
        const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg); // Frame color.
        RenderNavHighlight(frame_bb, id);                                                   // Highlight.
        RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);    // Render.

        // Slider behavior                                                                  // Comment.
        ImRect grab_bb1, grab_bb2;                                                          // Grab rects.
        const bool value_changed = RangeSliderBehavior(frame_bb, id, data_type, p_data1, p_data2, p_min, p_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb1, &grab_bb2); // Behavior.
        if (value_changed)                                                                  // If changed...
            MarkItemEdited(id);                                                             // Mark edited.

        // Render grabs                                                                     // Comment.
        if (grab_bb1.Max.y > grab_bb1.Min.y)                                                // If visible...
            window->DrawList->AddRectFilled(grab_bb1.Min, grab_bb1.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding); // Grab 1.
        if (grab_bb2.Max.y > grab_bb2.Min.y)                                                // If visible...
            window->DrawList->AddRectFilled(grab_bb2.Min, grab_bb2.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding); // Grab 2.
        // Render connector                                                                 // Comment.
        ImRect connector(grab_bb1.Min, grab_bb2.Max);                                       // Connector.
        float grab_sz = grab_bb1.Max.x - grab_bb1.Min.x;                                    // Grab size.
        connector.Min.x += grab_sz;                                                         // Adjust min.
        connector.Min.y += grab_sz * 0.3f;                                                  // Adjust min Y.
        connector.Max.x -= grab_sz;                                                         // Adjust max.
        connector.Max.y -= grab_sz * 0.3f;                                                  // Adjust max Y.
        window->DrawList->AddRectFilled(connector.Min, connector.Max, GetColorU32(ImGuiCol_RangeSliderBar), style.GrabRounding); // Draw connector.

        // Display value using user-provided display format so user can add prefix/suffix/decorations to the value. // Comment.
        // For the vertical slider we allow centered text to overlap the frame padding       // Comment.
        char value_buf[64];                                                                 // Buffer.
        const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, p_data1, p_data2, format); // Format.
        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.0f)); // Text.
        if (label_size.x > 0.0f)                                                            // If label...
            RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label); // Render label.

        return value_changed;                                                               // Return result.
    }                                                                                       // End function.

    bool ImGui::RangeVSliderFloat(const char* label, const ImVec2& size, float* v1, float* v2, float v_min, float v_max, const char* format, float power) // Implementation.
    {                                                                                       // Begin.
        return RangeVSliderScalar(label, size, ImGuiDataType_Float, v1, v2, &v_min, &v_max, format, power); // Call Scalar.
    }                                                                                       // End function.

    bool ImGui::RangeVSliderInt(const char* label, const ImVec2& size, int* v1, int* v2, int v_min, int v_max, const char* format) // Implementation.
    {                                                                                       // Begin.
        return RangeVSliderScalar(label, size, ImGuiDataType_S32, v1, v2, &v_min, &v_max, format); // Call Scalar.
    }                                                                                       // End function.
} // namespace ImGui                                                                        // End namespace.
